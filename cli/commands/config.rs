use crate::cli_args::ConfigArgs;
use crate::output::print_data_or_text; // Use unified output helper
use anyhow::{Context, Result};
use colored::*;
use std::fs;
use std::io::{self, Write};
use std::path::Path;
use toml; // Added use
use xcontext_core::{
    Config,
    config::{DEFAULT_CONFIG_DIR, DEFAULT_CONFIG_FILENAME}, // Use core constants
};

pub fn handle_config_command(args: &ConfigArgs, project_root: &Path, quiet: bool) -> Result<()> {
    let determined_name = project_root
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_else(|| "UnknownProject".to_string());

    let mut config_to_show_or_save = Config::default();
    config_to_show_or_save.general.project_name = Some(determined_name);

    if args.save {
        let default_config_path = project_root
            .join(DEFAULT_CONFIG_DIR)
            .join(DEFAULT_CONFIG_FILENAME);
        save_config_to_path(&config_to_show_or_save, &default_config_path, quiet)
    } else {
        // Serialize default config to TOML string for printing
        let toml_string = toml::to_string_pretty(&config_to_show_or_save) // Added use toml
            .context("Failed to serialize default config to TOML")?;
        // Use print_data_or_text (though it defaults to JSON/YAML/XML, text fallback works)
        print_data_or_text(
            &config_to_show_or_save,                       // Pass data even if using text
            Some(toml_string),                             // Provide the TOML string as plain text
            &crate::cli_args::FormatOutputOpts::default(), // Use default format options
            "text",                                        // Default to text for this command
            "Config",                                      // XML root name if XML were used
        )
    }
}

fn save_config_to_path(config: &Config, path: &Path, quiet: bool) -> Result<()> {
    if path.exists() {
        if quiet {
            anyhow::bail!(
                "Target file '{}' exists. Overwrite prevented in quiet mode.",
                path.display()
            );
        }
        print!(
            "{} Config file exists at '{}'. Overwrite? [{}/{}] ",
            "⚠️".yellow(),
            path.display().to_string().cyan(),
            "y".green(),
            "N".red()
        );
        io::stdout().flush().context("Failed to flush stdout")?;
        let mut response = String::new();
        io::stdin()
            .read_line(&mut response)
            .context("Failed to read user input")?;
        if !response.trim().eq_ignore_ascii_case("y") {
            println!("Save cancelled.");
            return Ok(());
        }
    }

    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    let header = format!(
        "{}\\n{}\\n\\n", // Add extra newline
        "# Default xcontext configuration", "# Generated by 'xcontext config --save'"
    );
    let toml_string =
        toml::to_string_pretty(config).context("Failed to serialize default config to TOML")?; // Added use toml
    let final_content = format!("{}{}", header, toml_string);

    fs::write(path, final_content)
        .with_context(|| format!("Failed to write config file {}", path.display()))?;

    if !quiet {
        println!(
            "{} Configuration saved successfully to: {}",
            "✅".green(),
            path.display().to_string().blue()
        );
    }
    Ok(())
}
