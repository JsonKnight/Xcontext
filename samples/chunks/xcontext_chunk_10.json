{"files":[{"path":"src/utils/show.rs","content":"// --- src/utils/show.rs ---\nuse crate::config::Config;\nuse crate::error::AppError;\nuse colored::*;\nuse once_cell::sync::Lazy;\nuse serde::Deserialize;\nuse std::collections::HashMap;\n\n// --- Structs for Loaded Data ---\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TextType {\n    Prompt,\n    Rules,\n}\n\n#[derive(Debug, Deserialize)]\npub struct AiReadmeText {\n    pub intro: String,\n    pub key_sections_header: String,\n    pub project_name_desc: String,\n    pub project_root_desc: String,\n    pub system_info_desc: String,\n    pub meta_desc: String,\n    pub docs_desc: String,\n    pub tree_desc: String,\n    pub source_files_desc: String,\n    pub source_chunks_desc: String,\n    pub source_missing_desc: String,\n    pub rules_desc: String,\n    pub rules_missing_desc: String,\n    pub timestamp_desc: String,\n}\n\n\n// --- Loaders using Lazy Static ---\n\nstatic PREDEFINED_PROMPTS: Lazy<HashMap<String, String>> = Lazy::new(|| {\n    let yaml_content = include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/data/prompts.yaml\"));\n    serde_yml::from_str(yaml_content).expect(\"Failed to parse embedded prompts.yaml\")\n});\n\nstatic PREDEFINED_RULES: Lazy<HashMap<String, String>> = Lazy::new(|| {\n    let yaml_content = include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/data/rules.yaml\"));\n    serde_yml::from_str(yaml_content).expect(\"Failed to parse embedded rules.yaml\")\n});\n\nstatic SOFT_IGNORE_PATTERNS: Lazy<Vec<String>> = Lazy::new(|| {\n    let yaml_content = include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/data/soft_ignores.yaml\"));\n    serde_yml::from_str(yaml_content).expect(\"Failed to parse embedded soft_ignores.yaml\")\n});\n\nstatic AI_README_TEXT: Lazy<AiReadmeText> = Lazy::new(|| {\n    let yaml_content = include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/data/ai_readme_text.yaml\"));\n    serde_yml::from_str(yaml_content).expect(\"Failed to parse embedded ai_readme_text.yaml\")\n});\n\n\n// --- Getter Functions ---\n\nfn get_predefined_prompts() -> &'static HashMap<String, String> {\n    &PREDEFINED_PROMPTS\n}\n\nfn get_predefined_rules() -> &'static HashMap<String, String> {\n    &PREDEFINED_RULES\n}\n\npub fn get_soft_ignore_patterns() -> &'static Vec<String> {\n    &SOFT_IGNORE_PATTERNS\n}\n\npub fn get_ai_readme_text() -> &'static AiReadmeText {\n    &AI_README_TEXT\n}\n\n// *** FIX: Moved Helper Functions Before Handlers ***\n\nfn list_available_keys(map: &HashMap<String, String>, item_type: &str) {\n    println!(\"Available {} keys:\", item_type);\n    if map.is_empty() {\n        println!(\"  (None available)\");\n        return;\n    }\n    let mut sorted_keys: Vec<_> = map.keys().map(|s| s.as_str()).collect();\n    sorted_keys.sort();\n    for key in sorted_keys {\n        println!(\"  - {}\", key.cyan());\n    }\n}\n\nfn list_static_rule_keys(map: &HashMap<String, String>) {\n    println!(\"Available {} keys:\", \"static ruleset\".yellow());\n    if map.is_empty() {\n        println!(\"  (None available)\");\n        return;\n    }\n    let mut sorted_keys: Vec<_> = map.keys().map(|s| s.as_str()).collect();\n    sorted_keys.sort();\n    for key in sorted_keys {\n        println!(\"  - {}\", key.cyan());\n    }\n}\n\n// --- Handler Functions ---\n\npub fn handle_show_meta(\n    config: &Config,\n    key_opt: Option<Option<String>>,\n    show_all: bool,\n) -> Result<(), AppError> {\n    if !config.meta.enabled {\n        eprintln!(\n            \"{}\",\n            \"Warning: Meta section is disabled in the configuration.\".yellow()\n        );\n        return Ok(());\n    }\n    let meta_data = &config.meta.custom_meta;\n    match key_opt {\n        Some(Some(k)) => {\n            if show_all { return Err(AppError::InvalidArg(\"--show-meta <KEY> and --show-meta-all cannot be used together.\".to_string())); }\n            if let Some(value) = meta_data.get(&k) { println!(\"{}\", value); }\n            else {\n                println!(\"{} Metadata key \\\"{}\\\" not found.\", \"Error:\".red(), k.cyan());\n                list_available_keys(meta_data, \"metadata\"); // Now in scope\n                return Err(AppError::UtilityMode { mode: \"--show-meta\".to_string(), details: format!(\"Metadata key \\\"{}\\\" not found.\", k), });\n            }\n        }\n        Some(None) => {\n            if show_all { return Err(AppError::InvalidArg(\"--show-meta (without key) and --show-meta-all cannot be used together.\".to_string())); }\n            println!(\"{}\", \"Please specify a metadata key or use --show-meta-all.\".yellow());\n            list_available_keys(meta_data, \"metadata\"); // Now in scope\n        }\n        None => {\n            if show_all {\n                if meta_data.is_empty() { println!(\"No custom metadata defined in config [meta] or via --add-meta.\"); return Ok(()); }\n                println!(\"{}\", \"Custom Metadata (from config [meta] and --add-meta):\".bold().underline());\n                let mut sorted_keys: Vec<_> = meta_data.keys().collect();\n                sorted_keys.sort();\n                for k in sorted_keys { println!(\"  {} = {}\", k.cyan(), meta_data.get(k).unwrap_or(&\"\".to_string())); }\n            } else { return Err(AppError::InvalidArg(\"Invalid state for show-meta flags.\".to_string())); }\n        }\n    }\n    Ok(())\n}\n\npub fn handle_show_prompt(\n    key_opt: Option<Option<String>>,\n    show_all: bool,\n    config: &Config,\n) -> Result<(), AppError> {\n    let predefined = get_predefined_prompts();\n    let mut merged_prompts = predefined.clone();\n    merged_prompts.extend(config.prompts.custom.clone());\n    match key_opt {\n        Some(Some(k)) => {\n            if show_all { return Err(AppError::InvalidArg(\"--show-prompt <NAME> and --show-prompts cannot be used together.\".to_string())); }\n            if let Some(text) = merged_prompts.get(&k) { println!(\"{}\", text.trim()); }\n            else {\n                println!(\"{} Prompt key \\\"{}\\\" not found.\", \"Error:\".red(), k.cyan());\n                list_available_keys(&merged_prompts, \"prompt\"); // Now in scope\n                return Err(AppError::UtilityMode { mode: \"--show-prompt\".to_string(), details: format!(\"Prompt key \\\"{}\\\" not found.\", k), });\n            }\n        }\n        Some(None) => {\n            if show_all { return Err(AppError::InvalidArg(\"--show-prompt (without name) and --show-prompts cannot be used together.\".to_string())); }\n            println!(\"{}\", \"Please specify a prompt name or use --show-prompts.\".yellow());\n            list_available_keys(&merged_prompts, \"prompt\"); // Now in scope\n        }\n        None => {\n            if show_all {\n                if merged_prompts.is_empty() { println!(\"No predefined or custom prompts found.\"); return Ok(()); }\n                println!(\"{}\", \"Available Prompts (Built-in + Custom in config [prompts])\".bold().underline());\n                let mut sorted_keys: Vec<_> = merged_prompts.keys().collect();\n                sorted_keys.sort();\n                for k in sorted_keys {\n                    println!(\"\\n▶ Name: {}\", k.cyan().bold());\n                    println!(\"---\");\n                    println!(\"{}\", merged_prompts.get(k).unwrap_or(&\"\".to_string()).trim());\n                    println!(\"---\");\n                }\n            } else { return Err(AppError::InvalidArg(\"Invalid state for show-prompt flags.\".to_string())); }\n        }\n    }\n    Ok(())\n}\n\n\npub fn handle_show_rule(\n    name_opt: Option<Option<String>>,\n    show_all: bool,\n    config: &Config,\n) -> Result<(), AppError> {\n    let static_rules_map = get_predefined_rules();\n    match name_opt {\n        Some(Some(n)) => {\n            if show_all { return Err(AppError::InvalidArg(\"--show-rule <NAME> and --show-rules cannot be used together.\".to_string())); }\n            if let Some(text) = static_rules_map.get(&n) { println!(\"{}\", text.trim()); }\n            else {\n                println!(\"{} Static ruleset name \\\"{}\\\" not found.\", \"Error:\".red(), n.cyan());\n                list_static_rule_keys(static_rules_map); // Now in scope\n                return Err(AppError::UtilityMode { mode: \"--show-rule\".to_string(), details: format!(\"Static ruleset name \\\"{}\\\" not found.\", n), });\n            }\n        }\n        Some(None) => {\n            if show_all { return Err(AppError::InvalidArg(\"--show-rule (without name) and --show-rules cannot be used together.\".to_string())); }\n            println!(\"{}\", \"Please specify a static ruleset name or use --show-rules.\".yellow());\n            list_static_rule_keys(static_rules_map); // Now in scope\n        }\n        None => {\n            if show_all {\n                println!(\"{}\\n---\", \"Available Static Rulesets:\".bold().underline());\n                if static_rules_map.is_empty() { println!(\"  {}\", \"(None defined internally)\".yellow()); }\n                else {\n                    let mut static_names: Vec<_> = static_rules_map.keys().collect();\n                    static_names.sort();\n                    for n in static_names {\n                        println!(\"\\n▶ Name: {}\", n.cyan().bold());\n                        println!(\"  ---\");\n                        println!(\"{}\", static_rules_map.get(n).unwrap_or(&\"\".to_string()).trim());\n                        println!(\"  ---\");\n                    }\n                }\n                println!(\"\\n{}\\n---\", \"Configured Custom Rule Lists:\".bold().underline());\n                if !config.rules.enabled { println!(\"  {}\", \"(Rules section disabled in config)\".yellow()); }\n                else if config.rules.custom_lists.is_empty() { println!(\"  {}\", \"(None defined in config [rules])\".yellow()); }\n                else {\n                    let mut sorted_custom_keys: Vec<_> = config.rules.custom_lists.keys().collect();\n                    sorted_custom_keys.sort();\n                    for list_name in sorted_custom_keys {\n                        if let Some(rules_list) = config.rules.custom_lists.get(list_name) {\n                            println!(\"\\n▶ List Name: {}\", list_name.cyan().bold());\n                            println!(\"  ---\");\n                            if rules_list.is_empty() { println!(\"  {}\", \"(Empty list)\".yellow()); }\n                            else { for rule in rules_list { println!(\"  - {}\", rule.trim()); } }\n                            println!(\"  ---\");\n                        }\n                    }\n                }\n            } else { return Err(AppError::InvalidArg(\"Invalid state for show-rule flags.\".to_string())); }\n        }\n    }\n    Ok(())\n}\n\n\npub fn get_predefined_text(name: &str, text_type: TextType) -> Result<String, AppError> {\n    let map = match text_type {\n        TextType::Prompt => get_predefined_prompts(),\n        TextType::Rules => get_predefined_rules(),\n    };\n    match map.get(name) {\n        Some(text) => Ok(text.clone()),\n        None => {\n            let type_str = match text_type { TextType::Prompt => \"prompt\", TextType::Rules => \"ruleset\" };\n            Err(AppError::Config(format!(\"Predefined {} name \\\"{}\\\" specified in config not found.\", type_str, name)))\n        }\n    }\n}\n"},{"path":"src/utils.rs","content":"// --- src/utils.rs ---\npub mod config_utils;\npub mod debug;\npub mod metrics;\npub mod quick;\npub mod show;\n// No new module needed if loader is in show.rs\n"}],"chunk_info":{"current_part":10,"total_parts":10}}