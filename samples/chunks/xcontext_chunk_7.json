{"files":[{"path":"src/main.rs","content":"// --- src/main.rs ---\nmod cli;\nmod config;\nmod context;\nmod error;\nmod output;\nmod system_info;\nmod utils;\n\nuse crate::cli::Cli;\nuse crate::config::{Config, DEFAULT_CONFIG_DIR, DEFAULT_CONFIG_FILENAME};\nuse crate::context::gather::{build_tree_from_paths, gather_files_and_tree, FileInfo};\nuse crate::context::ProjectContext;\nuse crate::error::AppError;\n\nuse clap::{CommandFactory, Parser};\nuse clap_complete::{generate, shells::Fish};\nuse clearscreen; // Added\nuse colored::*;\nuse notify_debouncer_mini::{new_debouncer, DebouncedEvent};\nuse std::collections::HashSet;\nuse std::fs;\nuse std::io::{Cursor};\nuse std::path::{Path, PathBuf};\nuse std::process;\nuse std::sync::{mpsc, Arc};\n\n\nfn main() {\n    let exit_code = match run_app() {\n        Ok(_) => 0,\n        Err(e) => {\n            eprintln!(\"{} {}\\n\", \"Error:\".red().bold(), e); // Added newline for clarity\n            e.exit_code()\n        }\n    };\n    process::exit(exit_code);\n}\n\n// Removed is_terminating_utility_mode as clap handles conflicts better now\n\nfn run_app() -> Result<(), AppError> {\n    let cli_args = Cli::parse();\n\n    // --- Handle -cl (Clear Screen) FIRST ---\n    if cli_args.other_utils.clear_screen {\n        clearscreen::clear().map_err(|e| AppError::UtilityMode {\n            mode: \"-cl\".to_string(),\n            details: format!(\"Failed to clear screen: {}\", e),\n        })?;\n        return Ok(());\n    }\n\n    // --- Handle Completions ---\n    if cli_args.completions_utils.completions_fish_show {\n        let mut cmd = Cli::command();\n        let mut buffer = Cursor::new(Vec::new());\n        generate(Fish, &mut cmd, \"xcontext\", &mut buffer);\n        let script = String::from_utf8(buffer.into_inner()).map_err(|e| {\n            AppError::UtilityMode {\n                mode: \"--completions-fish-show\".to_string(),\n                details: format!(\"Failed to convert script to UTF-8: {}\", e),\n            }\n        })?;\n        println!(\"{}\", script);\n        return Ok(());\n    }\n    if cli_args.completions_utils.completions_fish_save {\n        let mut cmd = Cli::command();\n        let mut buffer = Cursor::new(Vec::new());\n        generate(Fish, &mut cmd, \"xcontext\", &mut buffer);\n        let script = String::from_utf8(buffer.into_inner()).map_err(|e| {\n            AppError::UtilityMode {\n                mode: \"--completions-fish-save\".to_string(),\n                details: format!(\"Failed to convert script to UTF-8: {}\", e),\n            }\n        })?;\n        let completions_dir = dirs::config_dir()\n            .ok_or_else(|| AppError::UtilityMode {\n                mode: \"--completions-fish-save\".to_string(),\n                details: \"Could not determine config directory.\".to_string(),\n            })?\n            .join(\"fish\")\n            .join(\"completions\");\n        fs::create_dir_all(&completions_dir)\n            .map_err(|e| AppError::DirCreation { path: completions_dir.clone(), source: e })?;\n        let completions_path = completions_dir.join(\"xcontext.fish\");\n        fs::write(&completions_path, script)\n            .map_err(|e| AppError::FileWrite { path: completions_path.clone(), source: e })?;\n        println!(\"{} Fish completions saved to: {}\", \"✅\".green(), completions_path.display());\n        return Ok(());\n    }\n\n    // --- Config Show/Save Needs Project Root first ---\n     if cli_args.config_utils.config_show || cli_args.config_utils.config_save {\n         // Determine project root using the updated logic (CLI -> Env Var -> CWD)\n         let project_root = Config::determine_project_root(&cli_args)?;\n         // Determine project name based on CLI or root fallback\n         let determined_name = cli_args.config_project.project_name.clone()\n             .unwrap_or_else(|| project_root.file_name().map(|n| n.to_string_lossy().to_string()).unwrap_or_else(|| \"UnknownProject\".to_string()));\n\n         // Get default config and set the determined name & ensure default meta\n         let mut config_to_show_or_save = Config::default();\n         config_to_show_or_save.general.project_name = Some(determined_name);\n         // MetaConfig::default() now handles enabling and adding author=\"json\"\n\n         if cli_args.config_utils.config_show {\n             // Pass the prepared default config\n             return utils::debug::print_config_toml(&config_to_show_or_save);\n         }\n         if cli_args.config_utils.config_save {\n             let default_config_path = project_root.join(DEFAULT_CONFIG_DIR).join(DEFAULT_CONFIG_FILENAME);\n             // Pass the prepared default config\n             return utils::config_utils::save_config_to_path(&config_to_show_or_save, &default_config_path);\n         }\n     }\n\n\n    // --- Other Show Utilities Need Merged Config ---\n    if cli_args.show_utils.show_meta.is_some() || cli_args.show_utils.show_meta_all\n       || cli_args.show_utils.show_prompt.is_some() || cli_args.show_utils.show_prompts\n       || cli_args.show_utils.show_rule.is_some() || cli_args.show_utils.show_rules {\n            // Determine root first\n            let project_root_for_utils = Config::determine_project_root(&cli_args)?;\n            // Load the merged config as these utilities depend on potentially overridden values\n            let config_for_utils = Config::load_and_merge(&project_root_for_utils, &cli_args)?;\n\n            if cli_args.show_utils.show_meta.is_some() || cli_args.show_utils.show_meta_all {\n                return utils::show::handle_show_meta(&config_for_utils, cli_args.show_utils.show_meta, cli_args.show_utils.show_meta_all);\n            }\n            if cli_args.show_utils.show_prompt.is_some() || cli_args.show_utils.show_prompts {\n                return utils::show::handle_show_prompt(cli_args.show_utils.show_prompt, cli_args.show_utils.show_prompts, &config_for_utils);\n            }\n            if cli_args.show_utils.show_rule.is_some() || cli_args.show_utils.show_rules {\n                // Pass merged config for potential custom rules\n                return utils::show::handle_show_rule(cli_args.show_utils.show_rule, cli_args.show_utils.show_rules, &config_for_utils);\n            }\n            // Should be unreachable due to clap conflicts, but good practice\n            return Err(AppError::InvalidArg(\"Unhandled show utility mode state.\".to_string()));\n    }\n\n    // --- Info Utilities Need Merged Config & Gathered Files ---\n    // Debug and Metrics need to know *which* files would be included based on merged config.\n    // We handle them inside generate_and_output_context after gathering files.\n    // Determine root and load config *once* if we reach here (for Quick, Watch, or Generate).\n    let project_root = Config::determine_project_root(&cli_args)?;\n    let config = Arc::new(Config::load_and_merge(&project_root, &cli_args)?);\n\n    // --- Quick Mode Needs Merged Config ---\n    if let Some(pattern) = &cli_args.quick.quick {\n        let quick_config = Arc::clone(&config);\n        // Quick mode needs config for ignore settings\n        return utils::quick::run_quick_mode(&project_root, pattern, &quick_config);\n    }\n\n    // --- Watch Mode Needs Merged Config ---\n    if cli_args.watch.watch {\n        let watch_config = Arc::clone(&config);\n        let watch_project_root = project_root.clone();\n        let watch_cli_args = cli_args.clone(); // Clone Cli args for watch loop\n        return run_watch_mode(watch_project_root, watch_config, watch_cli_args);\n    }\n\n    // --- Default: Generate Context (also handles debug/metrics internally) ---\n    generate_and_output_context(project_root, config, &cli_args)\n}\n\n// This function handles the main context generation, including debug/metrics checks\nfn generate_and_output_context(\n    project_root: PathBuf,\n    config: Arc<Config>, // Takes merged config as Arc\n    cli_args: &Cli,\n) -> Result<(), AppError> {\n    validate_args_for_generation(&config, cli_args)?;\n\n    // Gather files based on the merged config (including soft ignores)\n    let (source_files, docs_files, tree_path_types) =\n        gather_files_and_tree(&project_root, &config)?;\n\n    // --- Handle Debug/Metrics Modes Here (as they need gathered files) ---\n    if cli_args.info_utils.debug {\n        // Pass config reference for printing\n        return utils::debug::print_debug_info(\n            &config,\n            &source_files,\n            &docs_files,\n            &tree_path_types,\n            &project_root,\n        );\n    }\n    if cli_args.info_utils.metrics {\n        let combined_files: Vec<&FileInfo> = source_files.iter().chain(docs_files.iter()).collect();\n        // Pass config reference for calculations\n        let metrics =\n            utils::metrics::calculate_metrics(&combined_files, &project_root, &config)?;\n        return utils::metrics::print_metrics(&metrics);\n    }\n\n    // --- Proceed with full context generation ---\n    let tree_for_context: Option<Vec<context::gather::TreeNode>> = if config.tree.enabled {\n        Some(build_tree_from_paths(&tree_path_types)?)\n    } else {\n        None\n    };\n\n    // Build context using merged config reference\n    let mut main_context = ProjectContext::build(\n        &project_root,\n        &config,\n        tree_for_context,\n    )?;\n\n    if config.is_docs_section_active() {\n        main_context = main_context.add_docs(docs_files, &project_root);\n    }\n\n    let mut output_target_path: Option<PathBuf> = None;\n    let needs_saving_to_disk =\n        cli_args.output_control.save.is_some() || cli_args.chunking.chunks.is_some();\n    let force_stdout = cli_args.output_control.stdout;\n    let default_to_stdout = !needs_saving_to_disk && !force_stdout;\n\n    if config.source.enabled {\n        if let Some(chunk_size_str) = &cli_args.chunking.chunks {\n            let (save_dir, _, _) =\n                config.get_save_details(cli_args.output_control.save.as_ref(), &project_root);\n            // Pass Arc config to chunking as it might be long-running\n            main_context = output::chunking::create_and_save_chunks(\n                main_context,\n                source_files,\n                Arc::clone(&config), // Clone Arc for chunking\n                cli_args.output_control.save.as_ref(),\n                &project_root,\n                chunk_size_str,\n                &save_dir,\n            )?;\n        } else {\n            main_context = main_context.add_files(source_files, &project_root);\n        }\n    }\n\n    if needs_saving_to_disk {\n        let (save_dir, filename_base, extension) =\n            config.get_save_details(cli_args.output_control.save.as_ref(), &project_root);\n        let is_chunked = cli_args.chunking.chunks.is_some();\n        let should_save_main = if is_chunked {\n            main_context\n                .source\n                .as_ref()\n                .map_or(!config.source.enabled, |s| s.chunks.is_some())\n        } else {\n            true\n        };\n        if should_save_main || cli_args.output_control.save.is_some() {\n            let main_filename = format!(\"{}.{}\", filename_base, extension);\n            output_target_path = Some(save_dir.join(main_filename));\n        }\n    }\n\n    // Populate readme using merged config reference\n    main_context.populate_ai_readme(&config);\n\n    if force_stdout || default_to_stdout {\n        // Pass config reference for output serialization settings\n        output::output_context(&main_context, &config, None)?;\n    } else if let Some(path) = output_target_path {\n        // Pass config reference for output serialization settings\n        output::output_context(&main_context, &config, Some(&path))?;\n    }\n    Ok(())\n}\n\nfn validate_args_for_generation(config: &Config, cli_args: &Cli) -> Result<(), AppError> {\n    if cli_args.chunking.chunks.is_some() {\n        if !config.source.enabled {\n            return Err(AppError::InvalidArg(\n                \"--chunks cannot be used when source file inclusion is disabled\".to_string(),\n            ));\n        }\n        if config.output.format != \"json\" {\n            return Err(AppError::Chunking(\n                \"Chunking requires the output format to be 'json'\".to_string(),\n            ));\n        }\n        if cli_args.output_control.stdout {\n            return Err(AppError::InvalidArg(\n                \"--stdout cannot be used with --chunks\".to_string(),\n            ));\n        }\n    }\n    Ok(())\n}\n\n\nfn run_watch_mode(\n    project_root: PathBuf,\n    mut config: Arc<Config>, // Starts with initial merged config\n    cli_args: Cli, // Cloned CLI args\n) -> Result<(), AppError> {\n    println!(\n        \"👀 Starting watch mode for '{}'. Press Ctrl+C to exit.\",\n        project_root.display()\n    );\n\n    // Helper to watch a single path\n    fn watch_path(\n        watcher: &mut dyn notify::Watcher,\n        path: &Path,\n        watched_paths: &mut HashSet<PathBuf>,\n    ) -> Result<(), AppError> {\n        // Use canonicalize to handle symlinks consistently if possible\n        let path_to_watch = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());\n        if !watched_paths.contains(&path_to_watch) {\n            watcher\n                .watch(&path_to_watch, notify::RecursiveMode::NonRecursive)\n                .map_err(|e| {\n                    AppError::WatchError(format!(\"Failed to watch {}: {}\", path.display(), e))\n                })?;\n            watched_paths.insert(path_to_watch);\n        }\n        Ok(())\n    }\n\n    // --- Initial Generation ---\n    let initial_config = Arc::clone(&config);\n    let initial_project_root = project_root.clone();\n    // Call generate_and_output_context for initial run\n    // Pass initial_project_root here\n    if let Err(e) = generate_and_output_context(initial_project_root.clone(), initial_config, &cli_args) {\n        eprintln!(\"{} {}\", \"⚠️ Error during initial generation:\".yellow(), e);\n    } else {\n        println!(\"{}\", \"✅ Initial generation complete.\".green());\n    }\n\n    // --- Setup Watcher ---\n    let (debouncer_tx, main_rx) = mpsc::channel::<Result<Vec<DebouncedEvent>, notify::Error>>();\n    let delay = config.get_watch_delay()?;\n    let mut debouncer = new_debouncer(delay, debouncer_tx)\n        .map_err(|e| AppError::WatchError(format!(\"Failed to create debouncer: {}\", e)))?;\n    let mut watched_paths = HashSet::new(); // Track currently watched paths\n\n    // Helper to setup/reset watches based on current config\n    let setup_watches =\n        |current_config: &Arc<Config>,\n         watcher: &mut dyn notify::Watcher,\n         current_watched: &mut HashSet<PathBuf>|\n         -> Result<(), AppError> {\n        // Unwatch previous paths\n        for path in current_watched.iter() {\n            let _ = watcher.unwatch(path); // Ignore errors if already unwatched\n        }\n        current_watched.clear();\n\n        // Gather files based on *current* config to determine what to watch\n        match gather_files_and_tree(&project_root, current_config) {\n            Ok((source_files, docs_files, _)) => {\n                if current_config.source.enabled {\n                    for file_info in source_files {\n                        let _ = watch_path(watcher, &file_info.path, current_watched);\n                    }\n                }\n                if current_config.is_docs_section_active() {\n                    for file_info in docs_files {\n                        let _ = watch_path(watcher, &file_info.path, current_watched);\n                    }\n                }\n            }\n            Err(e) => {\n                // Log error but continue, maybe files will appear later\n                eprintln!(\"{} {}\", \"⚠️ Error gathering files for watch mode:\".yellow(), e);\n            }\n        }\n\n        // Watch the config file itself\n        let resolved_config_path = Config::resolve_config_path(\n            &project_root,\n            cli_args.config_project.context_file.as_ref(),\n            cli_args.config_project.disable_context_file,\n        )?;\n        if let Some(ref config_path_to_watch) = resolved_config_path {\n            if config_path_to_watch.exists() { // Only watch if it exists\n                 match watch_path(watcher, config_path_to_watch, current_watched) {\n                    Ok(_) => {},\n                    Err(e) => eprintln!(\"{} {}: {}\", \"⚠️ Error watching config file\".yellow(), config_path_to_watch.display(), e),\n                 }\n            }\n        }\n\n        if current_watched.is_empty() {\n            println!(\"{}\", \"⚠️ No source, documentation, or config files found to watch based on current configuration.\".yellow());\n        } else {\n            println!(\"🔍 Watching {} files/paths...\", current_watched.len());\n        }\n        Ok(())\n    };\n\n    // Setup initial watches\n    if let Err(e) = setup_watches(&config, debouncer.watcher(), &mut watched_paths) {\n        eprintln!(\"{} {}\", \"⚠️ Error setting up initial watches:\".yellow(), e);\n        // Decide whether to exit or try to continue\n        // return Err(e); // Or just log and proceed\n    }\n\n\n    // --- Watch Loop ---\n    loop {\n        match main_rx.recv() {\n            Ok(event_result) => match event_result {\n                Ok(debounced_events) => {\n                    if !debounced_events.is_empty() {\n                        // Check if the config file was among the changes\n                        let resolved_config_path = Config::resolve_config_path(\n                            &project_root,\n                            cli_args.config_project.context_file.as_ref(),\n                            cli_args.config_project.disable_context_file,\n                        )?;\n                        let config_changed = if let Some(ref current_config_path) = resolved_config_path {\n                            let canonical_config_path = current_config_path.canonicalize().ok();\n                            debounced_events.iter().any(|event| {\n                                // Compare canonical paths if possible\n                                let event_path_canonical = event.path.canonicalize().ok();\n                                if let (Some(conf_canon), Some(evt_canon)) = (&canonical_config_path, &event_path_canonical) {\n                                    conf_canon == evt_canon\n                                } else {\n                                    // Fallback to direct comparison\n                                    event.path == *current_config_path\n                                }\n                            })\n                        } else { false }; // No config file path resolved, so it couldn't have changed\n\n                        // Reload config and reset watches if config changed\n                        if config_changed {\n                            println!( \"\\n{}\", \"🔄 Detected change in config file. Reloading configuration...\".blue() );\n                            match Config::load_and_merge(&project_root, &cli_args) {\n                                Ok(reloaded_config) => {\n                                    config = Arc::new(reloaded_config); // Update the shared config\n                                    println!(\"{}\", \"✅ Configuration reloaded.\".green());\n                                    println!(\"{}\", \"🔄 Rewatching files based on new configuration...\".blue());\n                                    // Reset watches based on the *new* config\n                                    if let Err(e) = setup_watches(&config, debouncer.watcher(), &mut watched_paths) {\n                                        eprintln!(\"{} {}\", \"⚠️ Error setting up watches after config reload:\".yellow(), e);\n                                    }\n                                }\n                                Err(e) => {\n                                    eprintln!(\"{} {}\", \"⚠️ Error reloading config:\".yellow(), e);\n                                    // Keep using the old config if reload fails\n                                }\n                            }\n                        }\n\n                        // Regenerate context regardless of whether config changed (source file might have changed)\n                        println!( \"\\n{} {} event(s). Regenerating context...\", \"🔄 Detected file change in\".blue(), debounced_events.len() );\n                        let current_config = Arc::clone(&config); // Clone Arc for generation task\n                        let current_project_root = project_root.clone(); // Clone project_root for this generation\n                        // *** FIX: Add missing project_root argument ***\n                        if let Err(e) = generate_and_output_context(current_project_root, current_config, &cli_args) {\n                            eprintln!(\"{} {}\", \"⚠️ Error during regeneration:\".yellow(), e);\n                        } else {\n                            println!(\"{}\", \"✅ Regeneration complete.\".green());\n                        }\n                    }\n                }\n                Err(error) => {\n                    // Log notify errors\n                    eprintln!(\"{} {}\", \"⚠️ Watch error:\".yellow(), error);\n                }\n            },\n            Err(e) => {\n                // Channel disconnected, exit loop\n                eprintln!(\"{} {}\", \"⛔ Watcher channel error:\".red(), e);\n                break;\n            }\n        }\n    }\n    Ok(())\n}\n"}],"chunk_info":{"current_part":7,"total_parts":10}}