{"files":[{"path":"src/utils/metrics.rs","content":"use crate::config::Config;\nuse crate::context::gather::FileInfo;\nuse crate::error::AppError;\nuse byte_unit::{Byte, UnitType};\nuse serde::Serialize;\nuse std::path::Path;\nuse tiktoken_rs::cl100k_base;\n\n#[derive(Debug, Serialize)]\npub struct ProjectMetrics {\n    pub total_files: usize,\n    pub total_lines: usize,\n    pub total_bytes: u128, // Use u128 consistently for total bytes\n    pub total_bytes_readable: String,\n    pub estimated_tokens: usize,\n    pub files_details: Vec<FileMetrics>,\n}\n\n#[derive(Debug, Serialize)]\npub struct FileMetrics {\n    pub path: String,\n    pub lines: usize,\n    pub bytes: usize,\n    pub bytes_readable: String,\n    pub estimated_tokens: usize,\n}\n\npub fn calculate_metrics(\n    files: &[&FileInfo],\n    project_root: &Path,\n    _config: &Config,\n) -> Result<ProjectMetrics, AppError> {\n    let bpe = cl100k_base().map_err(|e| AppError::TikToken(e.to_string()))?;\n    let mut total_files = 0;\n    let mut total_lines = 0;\n    let mut total_bytes: u128 = 0;\n    let mut total_tokens = 0;\n    let mut files_details = Vec::new();\n\n    for file_info in files {\n        let lines = file_info.content.lines().count();\n        let bytes = file_info.size; // usize\n\n        let tokens = bpe.encode_ordinary(&file_info.content).len();\n\n        let relative_path = pathdiff::diff_paths(&file_info.path, project_root)\n            .unwrap_or_else(|| file_info.path.clone())\n            .to_string_lossy()\n            .to_string();\n\n        total_files += 1;\n        total_lines += lines;\n        total_bytes += bytes as u128;\n        total_tokens += tokens;\n\n        let file_byte_option = Byte::from_u128(bytes as u128);\n        // Use .to_string() to format AdjustedByte\n        let file_size_readable = file_byte_option\n            .map(|b| b.get_appropriate_unit(UnitType::Binary).to_string()) // Changed .format(1) to .to_string()\n            .unwrap_or_else(|| \"0 B\".to_string());\n\n        files_details.push(FileMetrics {\n            path: relative_path,\n            lines,\n            bytes,\n            bytes_readable: file_size_readable,\n            estimated_tokens: tokens,\n        });\n    }\n\n    files_details.sort_by(|a, b| a.path.cmp(&b.path));\n\n    let total_byte_option = Byte::from_u128(total_bytes);\n    // Use .to_string() to format AdjustedByte\n    let total_size_readable = total_byte_option\n        .map(|b| b.get_appropriate_unit(UnitType::Binary).to_string()) // Changed .format(1) to .to_string()\n        .unwrap_or_else(|| \"0 B\".to_string());\n\n    Ok(ProjectMetrics {\n        total_files,\n        total_lines,\n        total_bytes,\n        total_bytes_readable: total_size_readable,\n        estimated_tokens: total_tokens,\n        files_details,\n    })\n}\n\npub fn print_metrics(metrics: &ProjectMetrics) -> Result<(), AppError> {\n    let json_output = serde_json::to_string_pretty(metrics)?;\n    println!(\"{}\", json_output);\n    Ok(())\n}\n"},{"path":"src/utils/quick.rs","content":"// --- src/utils/quick.rs ---\nuse crate::config::Config;\nuse crate::error::AppError;\nuse crate::output;\nuse crate::utils; // Added utils import\nuse glob::Pattern;\nuse ignore::WalkBuilder;\nuse ignore::overrides::OverrideBuilder;\nuse rayon::prelude::*;\nuse serde::Serialize;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\n\n// Removed const SOFT_IGNORE_PATTERNS array\n\n#[derive(Debug, Serialize)]\nstruct QuickOutput { files: HashMap<String, String> }\n\npub fn run_quick_mode( project_root: &Path, pattern: &str, config: &Arc<Config>, ) -> Result<(), AppError> {\n    let glob_pattern = Pattern::new(pattern).map_err(|e| AppError::Glob(format!(\"Invalid glob pattern for --quick: {}\", e)))?;\n    let mut files_map = HashMap::new();\n\n    let use_gitignore = config.general.use_gitignore;\n    let enable_soft_ignore = config.general.enable_soft_ignore;\n\n    let mut builder = WalkBuilder::new(project_root);\n    builder.ignore(use_gitignore)\n           .git_ignore(use_gitignore)\n           .git_exclude(use_gitignore)\n           .require_git(false);\n\n    if enable_soft_ignore {\n        let mut override_builder = OverrideBuilder::new(project_root);\n        // Use loaded patterns\n        for p in utils::show::get_soft_ignore_patterns().iter() {\n            override_builder.add(&format!(\"!{}\", p)).map_err(|e| AppError::Ignore(e))?;\n        }\n        let overrides = override_builder.build().map_err(|e| AppError::Ignore(e))?;\n        builder.overrides(overrides);\n    }\n\n    let walker = builder.build_parallel();\n\n    let (tx_path, rx_path) = std::sync::mpsc::channel::<PathBuf>();\n    let glob_pattern_outer_clone = glob_pattern.clone();\n\n    walker.run(move || {\n        let tx = tx_path.clone();\n        let proj_root_clone = project_root.to_path_buf();\n        let glob_pattern_inner_clone = glob_pattern_outer_clone.clone();\n        Box::new(move |entry_result| {\n            if let Ok(entry) = entry_result {\n                if entry.file_type().map_or(false, |ft| ft.is_file()) {\n                    if let Some(relative_path) = pathdiff::diff_paths(entry.path(), &proj_root_clone) {\n                        if glob_pattern_inner_clone.matches_path(&relative_path) {\n                            let _ = tx.send(entry.path().to_path_buf());\n                        }\n                    }\n                }\n            }\n            ignore::WalkState::Continue\n        })\n    });\n\n    let paths_to_read: Vec<_> = rx_path.iter().collect();\n    let results: Vec<Result<(String, String), AppError>> = paths_to_read.par_iter().map(|path| {\n        let content = fs::read_to_string(path).map_err(|e| AppError::FileRead { path: path.clone(), source: e })?;\n        let relative_path = pathdiff::diff_paths(path, project_root).unwrap_or_else(|| path.clone()).to_string_lossy().to_string();\n        Ok((relative_path, content))\n    }).collect();\n\n    for result in results {\n        match result {\n            Ok((path_str, content)) => { files_map.insert(path_str, content); }\n            Err(e) => eprintln!(\"Warning: {}\", e),\n        }\n    }\n\n    let output_data = QuickOutput { files: files_map };\n    let content = match config.output.format.to_lowercase().as_str() {\n        \"yaml\" | \"yml\" => serde_yml::to_string(&output_data)?,\n        \"xml\" => quick_xml::se::to_string_with_root(\"QuickOutput\", &output_data).map_err(|e| AppError::XmlSerialize(e.to_string()))?,\n        _ => {\n            if config.output.json_minify { serde_json::to_string(&output_data)? }\n            else { serde_json::to_string_pretty(&output_data)? }\n        }\n    };\n\n    output::write_to_stdout(&content)?;\n    Ok(())\n}\n"}],"chunk_info":{"current_part":9,"total_parts":10}}