{"files":[{"path":".envrc","content":"## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Project Root & Directories\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport PROJECT_ROOT=\"$PWD\"\nexport PROJECT_BIN_DIR=\"$PROJECT_ROOT/bin\"\nexport PROJECT_SCRIPTS_DIR=\"$PROJECT_ROOT/scripts\"\nexport PROJECT_TARGET_DIR=\"$PROJECT_ROOT/target\"\n\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## XDG Directories (Commented Out for Now)\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n# export XDG_CONFIG_HOME=\"$PROJECT_ROOT/config\"\n# export XDG_CACHE_HOME=\"$PROJECT_ROOT/cache\"\n# export XDG_DATA_HOME=\"$PROJECT_ROOT/share\"\n# export XDG_STATE_HOME=\"$PROJECT_ROOT/state\"\n\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Project Binaries & Scripts\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nadd_to_path() {\n  [ -d \"$1\" ] && export PATH=\"$1:$PATH\"\n}\n\nadd_to_path \"$PROJECT_TARGET_DIR/release\"\nadd_to_path \"$PROJECT_BIN_DIR\"\nadd_to_path \"$PROJECT_SCRIPTS_DIR\"\n\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Rust Environment Setup\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport CARGO_TARGET_DIR=\"$PROJECT_TARGET_DIR\"     # Store compiled artifacts within the project\n# export RUSTUP_HOME=\"$PROJECT_ROOT/.rustup\"      # Keep Rustup isolated\n# export CARGO_HOME=\"$PROJECT_ROOT/.cargo\"        # Keep Cargo binaries and cache inside the project\n# add_to_path \"$CARGO_HOME/bin\"                   # Add Cargo binaries to PATH\n\nexport CARGO_INCREMENTAL=1                        # Enable incremental compilation for faster builds\nexport RUST_ANALYZER_CACHE_DIR=\"$PROJECT_ROOT/.rust-analyzer\" # Rust Analyzer LSP cache\n\nexport RUST_BACKTRACE=1                           # Enable backtraces for debugging\nexport RUST_LOG=\"debug\"                           # Default logging level for Rust apps\n\n# Optimize Rust builds\n# export CARGO_PROFILE_RELEASE_LTO=thin\n# export RUSTFLAGS=\"-C target-cpu=native\"\n\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Ruby Environment Setup\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport GEM_HOME=\"$PROJECT_ROOT/.gem\"             # Store installed gems locally\nexport GEM_PATH=\"$GEM_HOME:$GEM_PATH\"            # Ensure Ruby uses local gems\nadd_to_path \"$GEM_HOME/bin\"                      # Add local gems to PATH\n\nexport BUNDLE_PATH=\"$GEM_HOME/bundle\"            # Keep Bundler dependencies in the project\n\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Direnv Auto-Reload\n## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n# watch_file .envrc\n"},{"path":"Cargo.toml","content":"[package]\nname = \"xcontext\"\nversion = \"0.1.0\"\nedition = \"2024\"\ndescription = \"Generate structured project context for AI models\"\nbuild = \"build.rs\"\n\n[dependencies]\nanyhow = \"1.0.97\"\nbyte-unit = { version = \"5.1.6\", features = [\"serde\"] }\nchrono = { version = \"0.4.40\", features = [\"serde\"] }\nclap = { version = \"4.5.35\", features = [\"derive\"] }\nclap_complete = \"4.5.47\"\nclearscreen = \"4.0.1\"\ncolored = \"3.0.0\"\ndirs = \"6.0.0\"\nglob = \"0.3.2\"\nglobset = \"0.4.16\"\nignore = \"0.4.23\"\nnotify = \"8.0.0\"\nnotify-debouncer-mini = \"0.6.0\"\nonce_cell = \"1.21.3\"\nparse_duration = \"2.1.1\"\npathdiff = \"0.2.3\"\nquick-xml = { version = \"0.37.4\", features = [\"serde\", \"serialize\"] }\nrayon = \"1.10.0\"\nserde = { version = \"1.0.219\", features = [\"derive\"] }\nserde_json = \"1.0.140\"\nserde_yml = \"0.0.12\"\nshellexpand = \"3.1.1\"\nsysinfo = \"0.34.2\"\nthiserror = \"2.0.12\"\ntiktoken-rs = \"0.6.0\"\ntoml = \"0.8.20\"\nwalkdir = \"2.5.0\"\n"},{"path":"Gemfile","content":"# frozen_string_literal: true\n\nsource \"https://rubygems.org\"\n\n# ðŸ›  Built-in Ruby libraries\n# require 'open3'       # Run shell commands with stdout/stderr capture\n# require 'shellwords'  # Safely escape command arguments\n# require 'yaml'        # Parse YAML files\n# require 'json'        # Parse JSON responses\n# require 'benchmark'   # Measure CLI execution time\n# require 'timecop'     # Freeze/manipulate time in tests (if needed)\n\n# ðŸ”¹ Core testing tools\ngem 'aruba'             # CLI testing framework\ngem 'rspec'             # Main testing framework\ngem 'rspec-expectations' # Provides matchers like expect(...).to eq(...)\ngem 'tty-command'       # Run shell commands & capture output\ngem 'toml-rb'          # Parse TOML files (for Cargo/Rust configs)\n\n# ðŸ”¹ Additional utilities for CLI testing\ngem 'fakefs'           # Simulates a filesystem for isolated tests\ngem 'webmock'          # Mocks HTTP requests (if CLI interacts with APIs)\ngem 'httparty'         # Lightweight HTTP client for testing API calls\n"},{"path":"Rakefile","content":"# frozen_string_literal: true\n\n# Rakefile\n\nPROJ_NAME = 'xcontext'\n\nBIN_NAME = 'xcontext'\nOUT_BIN = \"~/.bin/xtools/#{BIN_NAME}\"\n\nnamespace 'xrake' do\n  desc 'prod -+ Move xcontext to bin folder'\n  task production_deploy: 'cargo:clean_build' do\n    source = File.join(PROJECT_ROOT, \"target/release/#{BIN_NAME}\")\n    target = File.expand_path(OUT_BIN)\n    mv(source, target)\n  end\nend\n\ntask prod: 'xrake:production_deploy'\n"},{"path":"build.rs","content":"// --- build.rs ---\nfn main() {\n    println!(\"cargo:rerun-if-changed=data/prompts.yaml\");\n    println!(\"cargo:rerun-if-changed=data/rules.yaml\");\n    println!(\"cargo:rerun-if-changed=data/soft_ignores.yaml\");\n    println!(\"cargo:rerun-if-changed=data/ai_readme_text.yaml\"); // Added this line\n}\n"},{"path":"data/ai_readme_text.yaml","content":"intro: \"AI Readme: This JSON object provides context about a software project. Use this information to understand the project's structure, code, documentation, and guidelines.\"\nkey_sections_header: \"\\nKey Sections Explained:\"\nproject_name_desc: \"- 'project_name': Identifies the project.\"\nproject_root_desc: \"- 'project_root': The base directory path.\"\nsystem_info_desc: \"- 'system_info': Details about the environment where this context was generated.\"\nmeta_desc: \"- 'meta': Contains user-defined key-value pairs relevant to the project.\"\ndocs_desc: \"- 'docs': An array of documentation files. Each object has 'path' (relative to project root) and 'content'.\"\ntree_desc: \"- 'tree': Represents the project's directory structure hierarchically. Each node has 'name', 'type' ('file' or 'directory'), and optional 'children'.\"\nsource_files_desc: \"- 'source.files': An array of source code files. Each object has 'path' (relative) and 'content'. **Analyze this code carefully.**\"\nsource_chunks_desc: \"- 'source.chunks': An array of relative paths to chunk files (JSON). Load these files to get the complete source code context. The main context was too large.\"\nsource_missing_desc: \"- 'source': (Not included or empty) No source files matched the configuration filters.\"\nrules_desc: \"- 'rules': Contains coding standards, guidelines, or instructions. Keys are rule set names (e.g., 'instructions', 'project_rules'). Values are arrays of rule strings (often prefixed with '- '). **Follow these rules strictly.**\"\nrules_missing_desc: \"- 'rules': (Not included or empty) No rules were defined or enabled.\"\ntimestamp_desc: \"- 'generation_timestamp': Indicates when this context was created (UTC).\"\n"},{"path":"data/prompts.yaml","content":"general: |\n  Analyze the provided project context (metadata, structure, code).\n\ngeneral_chunks: |\n  Analyze the provided project context (metadata, structure, rules).\n  The source code is split into multiple chunks referenced in the 'chunks' array.\n  Process the main context first, then request and process each chunk file sequentially.\n\nrefactor_rust: |\n  Given the Rust project context, identify areas for refactoring focusing on\n  improving code structure, adhering to Rust best practices (like error handling,\n  lifetimes), and enhancing performance. Use the provided rules.\n"},{"path":"data/rules.yaml","content":"general_coding: |\n  - Write clear, concise, and maintainable code.\n  - Use meaningful variable and function names.\n  - Avoid magic numbers and strings.\n  - Keep functions and methods short and single-purpose.\n  - Follow project-specific style guides.\n\ninstructions: |\n  - Don't add comments in the code output, don't do it. NEVER NEVER NEVER.\n  - Always show full file content, not partial one\n  - You can add explantions and complex decisions and architecture patterns and anything you wanna tell in `AI.org` file\n  - Make sure to keep the README.org and SPEC.org files up to date\n  - For Rust CLI Options - Make sure to keep the CLI.org file up to date\n\nrust_coding: |\n  - Try to keep every file under 700 lines max.\n  - Follow Rust API guidelines.\n  - Use Rust OOP Pattern\n  - Write idiomatic Rust code (e.g., use iterators, pattern matching).\n  - Prefer standard library types over custom ones where applicable.\n  - Use `Result` for recoverable errors and `panic!` for unrecoverable ones.\n  - Keep functions small and focused.\n  - Apply the DRY (Don't Repeat Yourself) principle.\n  - Ensure proper error handling and propagation.\n  - Don't write tests; If you need to write some testing we can use ruby auruba for that purpose.\n\nruby_coding: |\n  - Write idiomatic Ruby; prefer Ruby constructs over C-style loops.\n  - Use Enumerable methods (`each`, `map`, `select`, `reject`, `inject`/`reduce`, etc.) effectively.\n  - Use blocks, Procs, and Lambdas where appropriate.\n  - Follow the Principle of Least Surprise.\n  - Use Bundler for managing gem dependencies (`Gemfile`, `Gemfile.lock`).\n  - Adhere to community style guides (e.g., Ruby Style Guide).\n  - Prefer symbols over strings for keys in hashes or options.\n  - Use predicate methods (ending in `?`) for boolean results.\n  - Use bang methods (ending in `!`) for methods that modify the object or raise errors on failure.\n\nc_coding: |\n  - Manage memory carefully: pair `malloc`/`calloc` with `free`. Check for allocation failures.\n  - Use header guards (`#ifndef`/`#define`/`#endif`) to prevent multiple inclusions.\n  - Prefer standard library functions (`<stdio.h>`, `<stdlib.h>`, `<string.h>`, etc.).\n  - Be cautious of buffer overflows; use bounded string/memory functions (e.g., `strncpy`, `snprintf`).\n  - Define functions clearly with prototypes.\n  - Use `const` for data that should not be modified.\n  - Keep functions small and focused on a single task.\n  - Follow a consistent coding style.\n  - Check return values of functions, especially I/O and memory allocation.\n\ncpp_coding: |\n  - Embrace RAII (Resource Acquisition Is Initialization) for resource management.\n  - Prefer smart pointers (`std::unique_ptr`, `std::shared_ptr`) over raw pointers.\n  - Use `const` correctness extensively.\n  - Prefer standard library containers and algorithms (`<vector>`, `<string>`, `<algorithm>`, etc.).\n  - Use C++11/14/17/20 features where appropriate (e.g., `auto`, range-based for loops, lambdas).\n  - Use header guards or `#pragma once` to prevent multiple inclusions.\n  - Keep header files minimal; forward declare where possible.\n  - Follow a consistent coding style (e.g., Google C++ Style Guide, LLVM).\n  - Handle errors appropriately (exceptions or error codes, consistently).\n  - Write unit tests for core functionality.\n\ngo_coding: |\n  - Format code with `gofmt` (or `goimports`).\n  - Handle errors explicitly; check error return values.\n  - Use interfaces effectively to define behavior.\n  - Keep packages focused and well-defined. Avoid cyclic dependencies.\n  - Use goroutines and channels for concurrency where appropriate, but avoid complexity if not needed.\n  - Write effective Go: keep code simple and clear.\n  - Use short variable names for short scopes.\n  - Write tests using the standard `testing` package.\n  - Follow standard package naming conventions (lowercase, no underscores).\n  - Document exported types, functions, constants, and variables.\n"}],"chunk_info":{"current_part":1,"total_parts":10}}