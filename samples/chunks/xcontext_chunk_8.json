{"files":[{"path":"src/output/chunking.rs","content":"use crate::config::Config;\nuse crate::context::gather::FileInfo;\nuse crate::context::{ChunkFile, ChunkInfo, FileContextInfo, ProjectContext};\nuse crate::error::AppError;\nuse crate::output::output_chunk_file;\nuse byte_unit::Byte;\nuse std::convert::TryInto;\nuse std::path::{Path, PathBuf};\nuse std::str::FromStr; // Moved import here\nuse std::sync::Arc;\n\npub fn create_and_save_chunks(\n    main_context: ProjectContext,\n    source_files: Vec<FileInfo>,\n    config: Arc<Config>,\n    cli_save_dir_opt: Option<&PathBuf>,\n    project_root: &Path,\n    chunk_size_str: &str,\n    save_dir: &Path,\n) -> Result<ProjectContext, AppError> {\n    let byte_value = Byte::from_str(chunk_size_str).map_err(|e| {\n        AppError::Chunking(format!(\n            \"Invalid chunk size format '{}': {}. Use KB, MB, etc.\",\n            chunk_size_str, e\n        ))\n    })?;\n    // Use .into() to convert Byte to u128\n    let target_chunk_size_bytes: u128 = byte_value.into();\n\n    let target_chunk_size_bytes_usize = target_chunk_size_bytes.try_into().map_err(|_| {\n        AppError::Chunking(\"Chunk size exceeds maximum usize value on this platform.\".to_string())\n    })?;\n\n    if target_chunk_size_bytes_usize == 0 {\n        return Err(AppError::Chunking(\n            \"Chunk size must be greater than 0 bytes\".to_string(),\n        ));\n    }\n\n    let (_, filename_base, extension) = config.get_save_details(cli_save_dir_opt, project_root);\n\n    let mut chunks: Vec<Vec<FileContextInfo>> = Vec::new();\n    let mut current_chunk_files: Vec<FileContextInfo> = Vec::new();\n    let mut current_chunk_size: usize = 0;\n\n    let all_file_contexts: Vec<FileContextInfo> = source_files\n        .into_iter()\n        .map(|finfo| {\n            let relative_path = pathdiff::diff_paths(&finfo.path, project_root)\n                .unwrap_or_else(|| finfo.path.clone())\n                .to_string_lossy()\n                .to_string();\n            FileContextInfo {\n                path: relative_path,\n                content: finfo.content,\n            }\n        })\n        .collect();\n\n    for file_context in all_file_contexts {\n        let file_size = file_context.content.len();\n        if file_size > target_chunk_size_bytes_usize {\n            if !current_chunk_files.is_empty() {\n                chunks.push(std::mem::take(&mut current_chunk_files));\n                current_chunk_size = 0;\n            }\n            chunks.push(vec![file_context]);\n            continue;\n        }\n        if !current_chunk_files.is_empty()\n            && (current_chunk_size + file_size) > target_chunk_size_bytes_usize\n        {\n            chunks.push(std::mem::take(&mut current_chunk_files));\n            current_chunk_files = vec![file_context];\n            current_chunk_size = file_size;\n        } else {\n            current_chunk_size += file_size;\n            current_chunk_files.push(file_context);\n        }\n    }\n    if !current_chunk_files.is_empty() {\n        chunks.push(current_chunk_files);\n    }\n\n    let total_parts = chunks.len();\n    if total_parts == 0 {\n        return Ok(main_context.add_chunk_paths(Vec::new(), save_dir));\n    }\n\n    let mut chunk_file_paths = Vec::<PathBuf>::new();\n    for (i, chunk_files) in chunks.into_iter().enumerate() {\n        let chunk_num = i + 1;\n        let chunk_info = ChunkInfo {\n            current_part: chunk_num,\n            total_parts,\n        };\n        let chunk_data = ChunkFile {\n            files: chunk_files,\n            chunk_info,\n        };\n        let chunk_filename = format!(\"{}_chunk_{}.{}\", filename_base, chunk_num, extension);\n        let chunk_path = save_dir.join(&chunk_filename);\n        output_chunk_file(&chunk_data, &chunk_path, config.output.json_minify)?;\n        chunk_file_paths.push(chunk_path);\n    }\n\n    let updated_context = main_context.add_chunk_paths(chunk_file_paths, save_dir);\n    Ok(updated_context)\n}\n"},{"path":"src/output.rs","content":"pub mod chunking;\n\nuse crate::config::Config;\n// Removed unused SourceRepresentation import\nuse crate::context::{ChunkFile, ProjectContext};\nuse crate::error::AppError;\nuse std::fs::{self, File};\nuse std::io::{self, Write};\nuse std::path::Path;\n\npub fn output_context(\n    context: &ProjectContext,\n    config: &Config,\n    output_path: Option<&Path>,\n) -> Result<(), AppError> {\n    let content = serialize_context(context, config)?;\n\n    match output_path {\n        Some(path) => {\n            write_to_file(path, &content)?;\n            // Update check for chunks using pub field\n            let is_chunked = context.source.as_ref().map_or(false, |s| s.chunks.is_some());\n            if !is_chunked {\n                println!(\"Context saved to: {}\", path.display());\n            }\n        }\n        None => {\n            write_to_stdout(&content)?;\n        }\n    }\n    Ok(())\n}\n\npub fn output_chunk_file(\n    chunk_data: &ChunkFile,\n    path: &Path,\n    minify: bool,\n) -> Result<(), AppError> {\n    let content = serialize_chunk(chunk_data, minify)?;\n    write_to_file(path, &content)?;\n    println!(\"Chunk saved to: {}\", path.display());\n    Ok(())\n}\n\nfn serialize_context(context: &ProjectContext, config: &Config) -> Result<String, AppError> {\n    match config.output.format.to_lowercase().as_str() {\n        \"yaml\" | \"yml\" => serde_yml::to_string(context).map_err(AppError::YamlSerialize),\n        \"xml\" => quick_xml::se::to_string_with_root(\"ProjectContext\", context)\n            .map_err(|e| AppError::XmlSerialize(e.to_string())),\n        _ => {\n            if config.output.json_minify { // Use correct field name\n                serde_json::to_string(context).map_err(AppError::JsonSerialize)\n            } else {\n                serde_json::to_string_pretty(context).map_err(AppError::JsonSerialize)\n            }\n        }\n    }\n}\n\nfn serialize_chunk(chunk_data: &ChunkFile, minify: bool) -> Result<String, AppError> {\n    if minify {\n        serde_json::to_string(chunk_data).map_err(AppError::JsonSerialize)\n    } else {\n        serde_json::to_string_pretty(chunk_data).map_err(AppError::JsonSerialize)\n    }\n}\n\nfn write_to_file(path: &Path, content: &str) -> Result<(), AppError> {\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).map_err(|e| AppError::DirCreation { path: parent.to_path_buf(), source: e, })?;\n    }\n    let mut file = File::create(path).map_err(|e| AppError::FileWrite { path: path.to_path_buf(), source: e, })?;\n    file.write_all(content.as_bytes())\n        .map_err(|e| AppError::FileWrite { path: path.to_path_buf(), source: e, })?;\n    Ok(())\n}\n\npub fn write_to_stdout(content: &str) -> Result<(), AppError> {\n    let stdout = io::stdout();\n    let mut handle = stdout.lock();\n    handle.write_all(content.as_bytes())?;\n    handle.flush()?;\n    Ok(())\n}\n"},{"path":"src/system_info.rs","content":"// --- src/system_info.rs ---\nuse crate::error::AppError;\nuse serde::{Deserialize, Serialize};\nuse std::env;\n// Remove Command usage: use std::process::Command;\nuse sysinfo::{System}; // Use sysinfo crate\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Default)] // Added default\npub struct SystemInfo {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    os_name: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    os_version: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    kernel_version: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    hostname: Option<String>,\n    // Removed xsystem_output\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    shell: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    term: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    error: Option<String>, // Keep error for potential internal issues\n}\n\npub fn gather_system_info() -> Result<SystemInfo, AppError> {\n    let mut info = SystemInfo::default(); // Use default\n\n    info.shell = env::var(\"SHELL\").ok();\n    info.term = env::var(\"TERM\").ok();\n\n    // Use sysinfo crate - safer than panicking if something isn't available\n    let mut sys = System::new_all();\n    sys.refresh_all(); // Refresh data\n\n    info.os_name = System::name(); // e.g., \"Linux\", \"Windows\", \"Darwin\"\n    info.os_version = System::os_version(); // e.g., \"5.15.0-...\" or \"11.1\"\n    info.kernel_version = System::kernel_version(); // Detailed kernel version\n    info.hostname = System::host_name(); // System hostname\n\n    // If sysinfo fails to get something, it returns None, which is handled by skip_serializing_if\n\n    Ok(info)\n}\n"},{"path":"src/utils/config_utils.rs","content":"// --- src/utils/config_utils.rs ---\nuse crate::config::Config;\nuse crate::error::AppError;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::Path;\n\n// No significant changes needed here, as main.rs now prepares the config\n// with the project name before calling this.\npub fn save_config_to_path(config: &Config, path: &Path) -> Result<(), AppError> {\n    if path.exists() {\n        print!( \"Configuration file already exists at '{}'. Overwrite? [y/N]: \", path.display() );\n        io::stdout().flush().map_err(AppError::Io)?;\n        let mut response = String::new();\n        io::stdin().read_line(&mut response).map_err(AppError::Io)?;\n        if !response.trim().eq_ignore_ascii_case(\"y\") {\n            println!(\"Save cancelled.\");\n            return Ok(());\n        }\n    }\n\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).map_err(|e| AppError::DirCreation { path: parent.to_path_buf(), source: e, })?;\n    }\n\n    // Use the config passed in (which now includes project name etc.)\n    let toml_string = toml::to_string_pretty(config)?;\n\n    fs::write(path, toml_string).map_err(|e| AppError::FileWrite { path: path.to_path_buf(), source: e, })?;\n\n    println!(\"Configuration saved successfully to: {}\", path.display());\n    Ok(())\n}\n"},{"path":"src/utils/debug.rs","content":"// --- src/utils/debug.rs ---\nuse crate::config::Config;\nuse crate::context::gather::FileInfo;\nuse crate::error::AppError;\nuse serde::Serialize;\nuse std::path::Path;\n\n#[derive(Debug, Serialize)]\npub struct DebugInfo {\n    effective_config: Config, // Keep as Config\n    source_files_to_include: Vec<String>,\n    docs_files_to_include: Vec<String>,\n    tree_elements_to_include: Vec<(String, bool)>,\n}\n\npub fn print_debug_info(\n    config: &Config, // Receive reference\n    source_files: &[FileInfo],\n    docs_files: &[FileInfo],\n    tree_path_types: &[(String, bool)],\n    project_root: &Path,\n) -> Result<(), AppError> {\n    let source_file_paths = source_files.iter().map(|f| {\n        pathdiff::diff_paths(&f.path, project_root).map(|p| p.to_string_lossy().to_string()).unwrap_or_else(|| f.path.to_string_lossy().to_string())\n    }).collect();\n    let docs_file_paths = docs_files.iter().map(|f| {\n        pathdiff::diff_paths(&f.path, project_root).map(|p| p.to_string_lossy().to_string()).unwrap_or_else(|| f.path.to_string_lossy().to_string())\n    }).collect();\n    let tree_elements: Vec<(String, bool)> = tree_path_types.to_vec();\n\n    let debug_data = DebugInfo {\n        // Clone the config received for printing\n        effective_config: config.clone(),\n        source_files_to_include: source_file_paths,\n        docs_files_to_include: docs_file_paths,\n        tree_elements_to_include: tree_elements,\n    };\n\n    let json_output = serde_json::to_string_pretty(&debug_data)?;\n    println!(\"{}\", json_output);\n    Ok(())\n}\n\n// This function now receives the config with the project name already set\npub fn print_config_toml(config: &Config) -> Result<(), AppError> {\n    let toml_output = toml::to_string_pretty(config)?;\n    println!(\"{}\", toml_output);\n    Ok(())\n}\n"}],"chunk_info":{"current_part":8,"total_parts":10}}