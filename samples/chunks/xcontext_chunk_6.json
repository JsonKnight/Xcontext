{"files":[{"path":"src/context.rs","content":"// --- src/context.rs ---\npub mod gather;\n\nuse crate::config::Config;\nuse crate::context::gather::TreeNode;\nuse crate::error::AppError;\nuse crate::system_info::SystemInfo;\nuse crate::utils;\nuse chrono::{DateTime, Utc};\nuse serde::Serialize;\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\n#[derive(Debug, Serialize, Clone, Default)]\npub struct SourceRepresentation {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub files: Option<Vec<FileContextInfo>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub chunks: Option<Vec<String>>,\n}\n\n\n#[derive(Debug, Serialize, Clone)]\npub struct ProjectContext {\n    #[serde(skip_serializing_if = \"Option::is_none\", rename = \"ai_readme\")]\n    pub ai_readme: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub project_name: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub project_root: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub system_info: Option<SystemInfo>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub meta: Option<HashMap<String, String>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub docs: Option<Vec<FileContextInfo>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tree: Option<Vec<TreeNode>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub source: Option<SourceRepresentation>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub rules: Option<HashMap<String, Vec<String>>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub generation_timestamp: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct FileContextInfo { pub path: String, pub content: String }\n\n#[derive(Debug, Serialize, Clone)]\npub struct ChunkInfo { pub current_part: usize, pub total_parts: usize }\n\n#[derive(Debug, Serialize, Clone)]\npub struct ChunkFile { pub files: Vec<FileContextInfo>, pub chunk_info: ChunkInfo }\n\nfn prefix_rule(rule: &str) -> String {\n    let trimmed = rule.trim_start();\n    if trimmed.starts_with('-') || trimmed.starts_with('*') { rule.to_string() } else { format!(\"- {}\", rule) }\n}\n\nimpl ProjectContext {\n    // ... build, create_file_context_list, add_files, add_docs, add_chunk_paths methods remain the same ...\n    pub fn build( project_root_path: &Path, config: &Config, tree_structure: Option<Vec<TreeNode>>, ) -> Result<Self, AppError> {\n        let sys_info = if config.output.include_system_info { Some(crate::system_info::gather_system_info()?) } else { None };\n        let meta_map = if config.meta.enabled && !config.meta.custom_meta.is_empty() { Some(config.meta.custom_meta.clone()) } else { None };\n\n        let rules_section = if config.rules.enabled {\n            let mut rules_map: HashMap<String, Vec<String>> = HashMap::new();\n            if let Some(static_names) = &config.rules.static_rules {\n                for name in static_names {\n                    match utils::show::get_predefined_text(name, utils::show::TextType::Rules) {\n                        Ok(static_text) => {\n                            let prefixed_rules: Vec<String> = static_text.lines().map(str::trim).filter(|l| !l.is_empty()).map(prefix_rule).collect();\n                            if !prefixed_rules.is_empty() {\n                                rules_map.insert(name.clone(), prefixed_rules);\n                            }\n                        }\n                        Err(e) => { eprintln!(\"Warning: Could not load static ruleset '{}': {}\", name, e); }\n                    }\n                }\n            }\n            if !config.rules.custom_lists.is_empty() {\n                let mut sorted_custom_keys: Vec<_> = config.rules.custom_lists.keys().cloned().collect();\n                sorted_custom_keys.sort();\n                for key in sorted_custom_keys {\n                   if let Some(custom_rules) = config.rules.custom_lists.get(&key) {\n                       if !custom_rules.is_empty() {\n                           let prefixed_rules: Vec<String> = custom_rules.iter().map(|s| s.as_str()).map(prefix_rule).collect();\n                           rules_map.insert(key.clone(), prefixed_rules);\n                       }\n                   }\n               }\n            }\n            if rules_map.is_empty() { None } else { Some(rules_map) }\n        } else { None };\n\n        let context = ProjectContext {\n            ai_readme: None,\n            project_name: if config.output.include_project_name { config.general.project_name.clone() } else { None },\n            project_root: if config.output.include_project_root { Some(project_root_path.to_string_lossy().to_string()) } else { None },\n            system_info: sys_info,\n            meta: meta_map,\n            docs: None,\n            tree: if config.tree.enabled { tree_structure } else { None },\n            source: None,\n            rules: rules_section,\n            generation_timestamp: if config.output.include_timestamp { Some(Utc::now()) } else { None },\n        };\n        Ok(context)\n    }\n\n    fn create_file_context_list(files_info: Vec<gather::FileInfo>, project_root: &Path) -> Vec<FileContextInfo> {\n        files_info.into_iter().map(|finfo| FileContextInfo {\n            path: pathdiff::diff_paths(&finfo.path, project_root).unwrap_or_else(|| finfo.path.clone()).to_string_lossy().to_string(),\n            content: finfo.content,\n        }).collect()\n    }\n\n    pub fn add_files(mut self, source_files_info: Vec<gather::FileInfo>, project_root: &Path) -> Self {\n        if !source_files_info.is_empty() { self.source = Some(SourceRepresentation { files: Some(Self::create_file_context_list(source_files_info, project_root)), chunks: None, }); } else { self.source = None; }\n        self\n    }\n\n    pub fn add_docs(mut self, docs_files_info: Vec<gather::FileInfo>, project_root: &Path) -> Self {\n        if !docs_files_info.is_empty() { self.docs = Some(Self::create_file_context_list(docs_files_info, project_root)); }\n        self\n    }\n\n    pub fn add_chunk_paths(mut self, chunk_paths: Vec<PathBuf>, save_dir: &Path) -> Self {\n        if !chunk_paths.is_empty() {\n            let relative_chunk_paths = chunk_paths.into_iter().map(|p| { pathdiff::diff_paths(&p, save_dir).map(|rel_p| rel_p.to_string_lossy().to_string()).unwrap_or_else(|| p.to_string_lossy().to_string()) }).collect();\n            self.source = Some(SourceRepresentation { files: None, chunks: Some(relative_chunk_paths) });\n        } else { self.source = None; }\n        self\n    }\n\n\n    pub fn populate_ai_readme(&mut self, config: &Config) {\n        let readme_text = utils::show::get_ai_readme_text();\n        // *** FIX: Initialize parts as Vec<&str> ***\n        let mut parts: Vec<&str> = Vec::new();\n\n        // *** FIX: Push as &str ***\n        parts.push(readme_text.intro.as_str());\n\n        let mut details: Vec<&str> = Vec::new(); // Keep details as Vec<&str>\n        // Use .as_str() when getting descriptions\n        if self.project_name.is_some() { details.push(readme_text.project_name_desc.as_str()); }\n        if self.project_root.is_some() { details.push(readme_text.project_root_desc.as_str()); }\n        if self.system_info.is_some() && config.output.include_system_info { details.push(readme_text.system_info_desc.as_str()); }\n        if self.meta.is_some() && config.meta.enabled { details.push(readme_text.meta_desc.as_str()); }\n        if self.docs.is_some() && config.is_docs_section_active() { details.push(readme_text.docs_desc.as_str()); }\n        if self.tree.is_some() && config.tree.enabled { details.push(readme_text.tree_desc.as_str()); }\n\n        if let Some(source_repr) = &self.source {\n             if config.source.enabled {\n                 if source_repr.files.is_some() { details.push(readme_text.source_files_desc.as_str()); }\n                 else if source_repr.chunks.is_some() { details.push(readme_text.source_chunks_desc.as_str()); }\n             }\n        } else if config.source.enabled { details.push(readme_text.source_missing_desc.as_str()); }\n\n        if self.rules.is_some() && config.rules.enabled {\n             details.push(readme_text.rules_desc.as_str());\n        } else if config.rules.enabled { details.push(readme_text.rules_missing_desc.as_str()); }\n\n        if self.generation_timestamp.is_some() && config.output.include_timestamp { details.push(readme_text.timestamp_desc.as_str()); }\n\n        if !details.is_empty() {\n            // *** FIX: Push header as &str ***\n            parts.push(readme_text.key_sections_header.as_str());\n            // *** FIX: Extend with Vec<&str> ***\n            parts.extend(details);\n            // *** FIX: Join Vec<&str> ***\n            self.ai_readme = Some(parts.join(\"\\n\"));\n        } else {\n            // Use intro directly if no details\n            self.ai_readme = Some(readme_text.intro.clone());\n        }\n    }\n}\n"},{"path":"src/error.rs","content":"// --- src/error.rs ---\nuse std::path::PathBuf;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"Configuration Error: {0}\")]\n    Config(String),\n\n    #[error(\"TOML Parsing Error: {0}\")]\n    TomlParse(String),\n\n    #[error(\"TOML Serialization Error: {0}\")]\n    TomlSerialize(#[from] toml::ser::Error),\n\n    #[error(\"JSON Serialization Error: {0}\")]\n    JsonSerialize(#[from] serde_json::Error),\n\n    #[error(\"YAML Serialization Error: {0}\")]\n    YamlSerialize(#[from] serde_yml::Error),\n\n    #[error(\"XML Serialization/Deserialization Error: {0}\")]\n    XmlSerialize(String),\n\n    #[error(\"Filesystem Error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"File Read Error: Path '{path}', Error: {source}\")]\n    FileRead { path: PathBuf, source: std::io::Error },\n\n    #[error(\"File Write Error: Path '{path}', Error: {source}\")]\n    FileWrite { path: PathBuf, source: std::io::Error },\n\n    #[error(\"Directory Creation Error: Path '{path}', Error: {source}\")]\n    DirCreation { path: PathBuf, source: std::io::Error },\n\n    #[error(\"WalkDir Error: {0}\")]\n    WalkDir(String),\n\n    #[error(\"Ignore Error: {0}\")]\n    Ignore(#[from] ignore::Error),\n\n    #[error(\"Glob Pattern Error: {0}\")]\n    Glob(String),\n\n    #[error(\"Chunking Error: {0}\")]\n    Chunking(String),\n\n    // Updated wording - no longer external command\n    #[error(\"System Info Error: {0}\")]\n    SystemInfo(String),\n\n    #[error(\"Invalid Argument: {0}\")]\n    InvalidArg(String),\n\n    #[error(\"Utility Mode Error ({mode}): {details}\")]\n    UtilityMode { mode: String, details: String },\n\n    #[error(\"TikToken Error: {0}\")]\n    TikToken(String),\n\n    #[error(\"Watch Mode Error: {0}\")]\n    WatchError(String),\n}\n\nimpl AppError {\n    pub fn exit_code(&self) -> i32 {\n        match self {\n            AppError::Config(_) | AppError::TomlParse(_) | AppError::TomlSerialize(_) => 1,\n            AppError::Io(_) | AppError::FileRead { .. } | AppError::FileWrite { .. } | AppError::DirCreation { .. } | AppError::WalkDir(_) | AppError::Ignore(_) | AppError::Glob(_) => 2,\n            AppError::Chunking(_) => 3,\n            AppError::SystemInfo(_) => 4, // Reusing code 4\n            AppError::InvalidArg(_) => 5,\n            AppError::JsonSerialize(_) | AppError::YamlSerialize(_) | AppError::XmlSerialize(_) => 6,\n            AppError::UtilityMode { .. } => 7,\n            AppError::TikToken(_) => 8,\n            AppError::WatchError(_) => 9,\n        }\n    }\n}\n\nimpl From<quick_xml::se::SeError> for AppError { fn from(err: quick_xml::se::SeError) -> Self { AppError::XmlSerialize(err.to_string()) } }\nimpl From<quick_xml::DeError> for AppError { fn from(err: quick_xml::DeError) -> Self { AppError::XmlSerialize(err.to_string()) } }\nimpl From<notify::Error> for AppError { fn from(err: notify::Error) -> Self { AppError::WatchError(format!(\"File watcher error: {}\", err)) } }\nimpl From<globset::Error> for AppError { fn from(err: globset::Error) -> Self { AppError::Glob(format!(\"Globset error: {}\", err)) } }\n// Add From for sysinfo if needed, though errors are typically handled internally\n"}],"chunk_info":{"current_part":6,"total_parts":10}}