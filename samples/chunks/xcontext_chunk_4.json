{"files":[{"path":"src/config.rs","content":"// --- src/config.rs ---\nuse crate::cli::Cli;\nuse crate::error::AppError;\nuse parse_duration::parse;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::env; // Added for environment variables\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::time::Duration;\n\npub const DEFAULT_CONFIG_DIR: &str = \".xtools/xcontext\";\npub const DEFAULT_CONFIG_FILENAME: &str = \"xcontext.toml\";\npub const DEFAULT_CACHE_DIR: &str = \".xtools/xcontext/cache\";\npub const DEFAULT_WATCH_DELAY: &str = \"300ms\";\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct Config {\n    #[serde(default)]\n    pub general: GeneralConfig,\n    #[serde(default)]\n    pub meta: MetaConfig, // Meta is now enabled by default via impl Default\n    #[serde(default)]\n    pub docs: DocsConfig,\n    #[serde(default)]\n    pub tree: TreeConfig,\n    #[serde(default)]\n    pub source: SourceConfig,\n    #[serde(default)]\n    pub rules: RulesConfig,\n    #[serde(default)]\n    pub prompts: PromptsConfig,\n    #[serde(default)]\n    pub output: OutputConfig,\n    #[serde(default)]\n    pub save: SaveConfig,\n    #[serde(default)]\n    pub watch: WatchConfig,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct GeneralConfig {\n    #[serde(default)]\n    pub project_name: Option<String>,\n    #[serde(default = \"default_true\")]\n    pub use_gitignore: bool,\n    #[serde(default = \"default_true\")] // Added soft ignore field\n    pub enable_soft_ignore: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)] // Removed Default derive\npub struct MetaConfig {\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n    #[serde(flatten, default)]\n    pub custom_meta: HashMap<String, String>,\n}\n\n// Manual Default impl for MetaConfig to set default author\nimpl Default for MetaConfig {\n    fn default() -> Self {\n        let mut custom_meta = HashMap::new();\n        custom_meta.insert(\"author\".to_string(), \"json\".to_string());\n        MetaConfig {\n            enabled: default_true(),\n            custom_meta,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct DocsConfig {\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n    #[serde(default)]\n    pub use_gitignore: IgnoreSetting,\n    #[serde(default = \"default_docs_include\")]\n    pub include: Vec<String>,\n    #[serde(default)]\n    pub exclude: Vec<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct TreeConfig {\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n    #[serde(default)]\n    pub use_gitignore: IgnoreSetting,\n    #[serde(default)]\n    pub include: Vec<String>,\n    #[serde(default = \"default_tree_exclude\")]\n    pub exclude: Vec<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct SourceConfig {\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n    #[serde(default)]\n    pub use_gitignore: IgnoreSetting,\n    #[serde(default)]\n    pub include: Vec<String>,\n    #[serde(default = \"default_source_exclude\")]\n    pub exclude: Vec<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct RulesConfig {\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n    #[serde(default = \"default_static_rules\")]\n    pub static_rules: Option<Vec<String>>,\n    #[serde(flatten, default)]\n    pub custom_lists: HashMap<String, Vec<String>>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Default)]\npub struct PromptsConfig {\n    #[serde(flatten, default)]\n    pub custom: HashMap<String, String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct OutputConfig {\n    #[serde(default = \"default_format\")]\n    pub format: String,\n    #[serde(default = \"default_true\")]\n    pub json_minify: bool,\n    #[serde(default = \"default_true\")]\n    pub include_project_name: bool,\n    #[serde(default = \"default_true\")]\n    pub include_project_root: bool,\n    #[serde(default = \"default_true\")]\n    pub include_timestamp: bool,\n    #[serde(default = \"default_true\")]\n    pub include_system_info: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct SaveConfig {\n    #[serde(default = \"default_save_dir\")]\n    pub output_dir: PathBuf,\n    #[serde(default)]\n    pub filename_base: Option<String>,\n    #[serde(default)]\n    pub extension: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct WatchConfig {\n    #[serde(default = \"default_watch_delay_string\")]\n    pub delay: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum IgnoreSetting {\n    Inherit,\n    True,\n    False,\n}\n\nfn default_true() -> bool {\n    true\n}\nfn default_format() -> String {\n    \"json\".to_string()\n}\nfn default_save_dir() -> PathBuf {\n    PathBuf::from(DEFAULT_CACHE_DIR)\n}\nfn default_watch_delay_string() -> String {\n    DEFAULT_WATCH_DELAY.to_string()\n}\nfn default_docs_include() -> Vec<String> {\n    vec![\n        \"*.org\".to_string(),\n        \"*.md\".to_string(),\n        \"README*\".to_string(),\n        \"LICENSE*\".to_string(),\n    ]\n}\nfn default_tree_exclude() -> Vec<String> {\n    vec![\"meta/\".to_string()]\n}\nfn default_source_exclude() -> Vec<String> {\n    vec![\"meta/\".to_string()]\n}\nfn default_static_rules() -> Option<Vec<String>> {\n    Some(vec![\n        \"instructions\".to_string(),\n        \"general_coding\".to_string(),\n    ])\n}\n\nimpl Default for IgnoreSetting {\n    fn default() -> Self {\n        IgnoreSetting::Inherit\n    }\n}\nimpl Default for GeneralConfig {\n    fn default() -> Self {\n        GeneralConfig {\n            project_name: None,\n            use_gitignore: default_true(),\n            enable_soft_ignore: default_true(), // Default soft ignore to true\n        }\n    }\n}\nimpl Default for TreeConfig {\n    fn default() -> Self {\n        TreeConfig {\n            enabled: default_true(),\n            use_gitignore: IgnoreSetting::default(),\n            include: Vec::new(),\n            exclude: default_tree_exclude(),\n        }\n    }\n}\nimpl Default for SourceConfig {\n    fn default() -> Self {\n        SourceConfig {\n            enabled: default_true(),\n            use_gitignore: IgnoreSetting::default(),\n            include: Vec::new(),\n            exclude: default_source_exclude(),\n        }\n    }\n}\nimpl Default for DocsConfig {\n    fn default() -> Self {\n        DocsConfig {\n            enabled: default_true(),\n            use_gitignore: IgnoreSetting::default(),\n            include: default_docs_include(),\n            exclude: Vec::new(),\n        }\n    }\n}\nimpl Default for RulesConfig {\n    fn default() -> Self {\n        RulesConfig {\n            enabled: default_true(),\n            static_rules: default_static_rules(),\n            custom_lists: HashMap::new(),\n        }\n    }\n}\nimpl Default for OutputConfig {\n    fn default() -> Self {\n        OutputConfig {\n            format: default_format(),\n            json_minify: default_true(),\n            include_project_name: default_true(),\n            include_project_root: default_true(),\n            include_timestamp: default_true(),\n            include_system_info: default_true(),\n        }\n    }\n}\nimpl Default for SaveConfig {\n    fn default() -> Self {\n        SaveConfig {\n            output_dir: default_save_dir(),\n            filename_base: None,\n            extension: None,\n        }\n    }\n}\nimpl Default for WatchConfig {\n    fn default() -> Self {\n        WatchConfig {\n            delay: default_watch_delay_string(),\n        }\n    }\n}\nimpl Default for Config {\n    fn default() -> Self {\n        Config {\n            general: GeneralConfig::default(),\n            meta: MetaConfig::default(), // Use manual impl\n            docs: DocsConfig::default(),\n            tree: TreeConfig::default(),\n            source: SourceConfig::default(),\n            rules: RulesConfig::default(),\n            prompts: PromptsConfig::default(),\n            output: OutputConfig::default(),\n            save: SaveConfig::default(),\n            watch: WatchConfig::default(),\n        }\n    }\n}\n\nimpl Config {\n    // Updated Project Root Logic\n    pub fn determine_project_root(cli_args: &Cli) -> Result<PathBuf, AppError> {\n        let path_str_opt = cli_args\n            .config_project\n            .project_root\n            .as_ref()\n            .map(|p| p.to_string_lossy().to_string())\n            .or_else(|| env::var(\"PROJECT_ROOT\").ok().filter(|s| !s.is_empty())); // Check ENV var\n\n        let path_str = match path_str_opt {\n            Some(p_str) => p_str,\n            None => {\n                // Fallback to CWD\n                return std::env::current_dir()\n                    .map_err(AppError::Io)?\n                    .canonicalize()\n                    .map_err(AppError::Io);\n            }\n        };\n\n        let expanded_path_cow = shellexpand::tilde(&path_str);\n        let path = PathBuf::from(expanded_path_cow.as_ref());\n        path.canonicalize().map_err(AppError::Io)\n    }\n\n    pub fn resolve_config_path(\n        project_root: &Path,\n        cli_path_str: Option<&String>,\n        disable_context_file: bool,\n    ) -> Result<Option<PathBuf>, AppError> {\n        if disable_context_file {\n            return Ok(None);\n        }\n        let path_to_check = match cli_path_str {\n            Some(p_str) => {\n                let expanded_path_cow = shellexpand::tilde(p_str);\n                let mut path = PathBuf::from(expanded_path_cow.as_ref());\n                let looks_like_path = path.is_absolute()\n                    || path.components().count() > 1\n                    || p_str.contains('/')\n                    || p_str.contains('\\\\');\n                if looks_like_path {\n                    if path\n                        .extension()\n                        .map_or(true, |ext| ext.to_string_lossy().to_lowercase() != \"toml\")\n                    {\n                        path.set_extension(\"toml\");\n                    }\n                    if !path.exists() {\n                        return Err(AppError::Config(format!(\n                            \"Specified config file not found at absolute/relative path: {}\",\n                            path.display()\n                        )));\n                    }\n                    Some(path)\n                } else {\n                    if path\n                        .extension()\n                        .map_or(true, |ext| ext.to_string_lossy().to_lowercase() != \"toml\")\n                    {\n                        path.set_extension(\"toml\");\n                    }\n                    let full_path = project_root.join(DEFAULT_CONFIG_DIR).join(&path);\n                    if !full_path.exists() {\n                        return Err(AppError::Config(format!(\n                            \"Specified config file '{}' not found in default directory: {}\",\n                            path.display(),\n                            project_root.join(DEFAULT_CONFIG_DIR).display()\n                        )));\n                    }\n                    Some(full_path)\n                }\n            }\n            None => {\n                let default_path = project_root\n                    .join(DEFAULT_CONFIG_DIR)\n                    .join(DEFAULT_CONFIG_FILENAME);\n                if default_path.exists() {\n                    Some(default_path)\n                } else {\n                    None\n                }\n            }\n        };\n        Ok(path_to_check)\n    }\n\n    pub fn load_and_merge(project_root: &Path, cli_args: &Cli) -> Result<Self, AppError> {\n        let mut cfg = Config::default();\n        let config_path = Self::resolve_config_path(\n            project_root,\n            cli_args.config_project.context_file.as_ref(),\n            cli_args.config_project.disable_context_file,\n        )?;\n        if let Some(path) = &config_path {\n            if path.exists() {\n                let toml_content = fs::read_to_string(path).map_err(|e| AppError::FileRead {\n                    path: path.clone(),\n                    source: e,\n                })?;\n                let toml_cfg: Config = toml::from_str(&toml_content).map_err(|e| {\n                    AppError::TomlParse(format!(\"Error parsing '{}': {}\", path.display(), e))\n                })?;\n                cfg = toml_cfg;\n            }\n        }\n\n        // Determine final project name BEFORE applying CLI overrides that might depend on it\n        let final_project_name = cli_args\n            .config_project\n            .project_name\n            .clone()\n            .or_else(|| cfg.general.project_name.clone()) // Check config file value\n            .unwrap_or_else(|| {\n                project_root\n                    .file_name()\n                    .map(|n| n.to_string_lossy().to_string())\n                    .unwrap_or_else(|| \"UnknownProject\".to_string())\n            });\n        cfg.general.project_name = Some(final_project_name); // Set determined name in config\n\n        cfg.apply_cli_overrides(cli_args); // Apply other CLI overrides\n\n        Ok(cfg)\n    }\n\n    fn apply_cli_overrides(&mut self, cli: &Cli) {\n        // Project Name handled in load_and_merge\n\n        if let Some(format) = &cli.output_control.format {\n            self.output.format = format.clone();\n        }\n\n        let is_json_format = self.output.format.to_lowercase() == \"json\";\n        if cli.output_control.disable_json_minify {\n            self.output.json_minify = false;\n        } else if cli.output_control.enable_json_minify {\n            if is_json_format {\n                self.output.json_minify = true;\n            }\n        } else if !is_json_format {\n            self.output.json_minify = false;\n        }\n\n        if cli.exclusion.exclude_project_name {\n            self.output.include_project_name = false;\n        }\n        if cli.exclusion.exclude_project_root {\n            self.output.include_project_root = false;\n        }\n        if cli.exclusion.exclude_timestamp {\n            self.output.include_timestamp = false;\n        }\n        if cli.exclusion.exclude_system_info {\n            self.output.include_system_info = false;\n        }\n\n        if cli.section_toggles.disable_tree {\n            self.tree.enabled = false;\n        }\n        if cli.section_toggles.enable_tree {\n            self.tree.enabled = true;\n        }\n        if cli.section_toggles.disable_source {\n            self.source.enabled = false;\n        }\n        if cli.section_toggles.enable_source {\n            self.source.enabled = true;\n        }\n        if cli.section_toggles.disable_meta {\n            self.meta.enabled = false;\n        }\n        if cli.section_toggles.enable_meta {\n            self.meta.enabled = true;\n        }\n        if cli.section_toggles.disable_rules {\n            self.rules.enabled = false;\n        }\n        if cli.section_toggles.enable_rules {\n            self.rules.enabled = true;\n        }\n        if cli.section_toggles.disable_docs {\n            self.docs.enabled = false;\n        }\n        if cli.section_toggles.enable_docs {\n            self.docs.enabled = true;\n        }\n\n        // Handle Ignore Toggles\n        if cli.ignore_toggles.disable_gitignore {\n            self.general.use_gitignore = false;\n        }\n        if cli.ignore_toggles.enable_gitignore {\n            self.general.use_gitignore = true;\n        }\n        if cli.ignore_toggles.disable_soft_ignore {\n            self.general.enable_soft_ignore = false;\n        }\n        if cli.ignore_toggles.enable_soft_ignore {\n            self.general.enable_soft_ignore = true;\n        }\n\n        self.tree\n            .include\n            .extend(cli.filters.tree_include.iter().cloned());\n        self.tree\n            .exclude\n            .extend(cli.filters.tree_exclude.iter().cloned());\n        self.source\n            .include\n            .extend(cli.filters.source_include.iter().cloned());\n        self.source\n            .exclude\n            .extend(cli.filters.source_exclude.iter().cloned());\n        self.docs\n            .include\n            .extend(cli.filters.docs_include.iter().cloned());\n        self.docs\n            .exclude\n            .extend(cli.filters.docs_exclude.iter().cloned());\n\n        for (key, value) in &cli.meta_override.add_meta {\n            self.meta.custom_meta.insert(key.clone(), value.clone());\n        }\n\n        if let Some(delay_str) = &cli.watch.watch_delay {\n            self.watch.delay = delay_str.clone();\n        }\n    }\n\n    pub fn get_effective_project_name(&self) -> &str {\n        self.general\n            .project_name\n            .as_deref()\n            .unwrap_or(\"UnknownProject\")\n    }\n\n    pub fn get_save_details(\n        &self,\n        cli_save_dir_opt: Option<&PathBuf>,\n        project_root: &Path,\n    ) -> (PathBuf, String, String) {\n        let save_dir_base = cli_save_dir_opt\n            .cloned()\n            .unwrap_or_else(|| self.save.output_dir.clone());\n        let save_dir = if save_dir_base.is_absolute() {\n            save_dir_base\n        } else {\n            project_root.join(save_dir_base)\n        };\n        let filename_base = self\n            .save\n            .filename_base\n            .as_deref()\n            .or(self.general.project_name.as_deref()) // Use the determined project name\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| {\n                project_root\n                    .file_name()\n                    .map(|n| n.to_string_lossy().to_string())\n                    .unwrap_or_else(|| \"context\".to_string())\n            });\n        let extension = self.save.extension.as_deref().unwrap_or_else(|| {\n            match self.output.format.to_lowercase().as_str() {\n                \"yaml\" | \"yml\" => \"yaml\",\n                \"xml\" => \"xml\",\n                _ => \"json\",\n            }\n        });\n        (save_dir, filename_base, extension.to_string())\n    }\n\n    pub fn get_watch_delay(&self) -> Result<Duration, AppError> {\n        parse(&self.watch.delay).map_err(|e| {\n            AppError::InvalidArg(format!(\n                \"Invalid watch delay duration '{}': {}\",\n                self.watch.delay, e\n            ))\n        })\n    }\n    pub fn get_effective_gitignore(&self, section_setting: &IgnoreSetting) -> bool {\n        match section_setting {\n            IgnoreSetting::True => true,\n            IgnoreSetting::False => false,\n            IgnoreSetting::Inherit => self.general.use_gitignore,\n        }\n    }\n    pub fn is_docs_section_active(&self) -> bool {\n        self.docs.enabled && !self.docs.include.is_empty()\n    }\n}\n\nimpl From<toml::de::Error> for AppError {\n    fn from(err: toml::de::Error) -> Self {\n        AppError::TomlParse(err.to_string())\n    }\n}\n"}],"chunk_info":{"current_part":4,"total_parts":10}}