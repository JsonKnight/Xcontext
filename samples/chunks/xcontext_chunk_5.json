{"files":[{"path":"src/context/gather.rs","content":"// --- src/context/gather.rs ---\n#![allow(unused_variables)]\n\nuse crate::config::{Config}; // Removed DEFAULT_CACHE_DIR temporarily, let compiler decide\nuse crate::error::AppError;\nuse crate::utils;\nuse colored::Colorize;\nuse globset::{Glob, GlobSet, GlobSetBuilder};\nuse ignore::{WalkBuilder, WalkState}; // Keep WalkState\nuse ignore::overrides::OverrideBuilder;\nuse rayon::prelude::*; // Keep rayon\nuse serde::Serialize;\nuse std::collections::HashSet; // Keep HashSet\nuse std::fs; // Keep fs\nuse std::path::Component;\nuse std::path::{Path, PathBuf};\nuse std::sync::mpsc;\n\n\n#[derive(Debug, Clone)]\npub struct FileInfo {\n    pub path: PathBuf,\n    pub content: String,\n    pub size: usize,\n}\n\n#[derive(Serialize, Debug, Clone)]\npub struct TreeNode {\n    name: String,\n    #[serde(rename = \"type\")]\n    node_type: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    children: Option<Vec<TreeNode>>,\n}\n\nfn build_glob_set(patterns: &[String], project_root: &Path) -> Result<GlobSet, AppError> {\n    let mut builder = GlobSetBuilder::new();\n    for pattern_str in patterns {\n        let pattern_path = Path::new(pattern_str);\n        let mut adjusted_glob_str = pattern_str.clone();\n        if !pattern_str.ends_with('/') && !pattern_str.contains('*') {\n            let potential_dir_path = if pattern_path.is_absolute() { pattern_path.to_path_buf() } else { project_root.join(pattern_path) };\n            if potential_dir_path.is_dir() { adjusted_glob_str = format!(\"{}/**\", pattern_str); }\n        }\n        let glob_to_add = if Path::new(&adjusted_glob_str).is_absolute() { adjusted_glob_str } else { adjusted_glob_str };\n        match Glob::new(&glob_to_add) {\n            Ok(glob) => { builder.add(glob); }\n            Err(e) => { return Err(AppError::Glob(format!(\"Invalid glob pattern '{}' -> '{}': {}\", pattern_str, glob_to_add, e))) }\n        }\n    }\n    builder.build().map_err(|e| AppError::Glob(e.to_string()))\n}\n\nfn passes_filters_globset( absolute_path: &Path, relative_path: &Path, include_set: &GlobSet, exclude_set: &GlobSet, has_includes: bool ) -> bool {\n    let path_to_match = relative_path;\n    if exclude_set.is_match(path_to_match) { return false; }\n    if has_includes { if include_set.is_match(path_to_match) { return true; } else { return false; } }\n    true\n}\n\n\npub fn gather_files_and_tree( project_root: &Path, config: &Config, ) -> Result<(Vec<FileInfo>, Vec<FileInfo>, Vec<(String, bool)>), AppError> {\n    let (tx_entry, rx_entry) = mpsc::channel::<Result<ignore::DirEntry, ignore::Error>>();\n\n    let mut builder = WalkBuilder::new(project_root);\n    builder.threads(rayon::current_num_threads().min(12));\n\n    let use_global_gitignore = config.general.use_gitignore;\n    let use_tree_gitignore = config.get_effective_gitignore(&config.tree.use_gitignore);\n    let use_source_gitignore = config.get_effective_gitignore(&config.source.use_gitignore);\n    // *** FIX: Corrected the newline issue ***\n    let use_docs_gitignore = config.get_effective_gitignore(&config.docs.use_gitignore);\n    let apply_walkbuilder_gitignore = use_global_gitignore && use_tree_gitignore && use_source_gitignore && use_docs_gitignore;\n\n    builder.ignore(apply_walkbuilder_gitignore);\n    builder.git_ignore(apply_walkbuilder_gitignore);\n    builder.git_exclude(apply_walkbuilder_gitignore);\n    builder.require_git(false);\n\n    // --- Soft Ignore Logic ---\n    if config.general.enable_soft_ignore {\n        let mut override_builder = OverrideBuilder::new(project_root);\n        for pattern in utils::show::get_soft_ignore_patterns().iter() {\n            override_builder.add(&format!(\"!{}\", pattern)).map_err(|e| AppError::Ignore(e))?;\n        }\n        let overrides = override_builder.build().map_err(|e| AppError::Ignore(e))?;\n        builder.overrides(overrides);\n    }\n    // --- End Soft Ignore Logic ---\n\n\n    let tree_include_set = build_glob_set(&config.tree.include, project_root)?;\n    let tree_exclude_set = build_glob_set(&config.tree.exclude, project_root)?;\n    let has_tree_includes = !config.tree.include.is_empty();\n\n    let source_include_set = build_glob_set(&config.source.include, project_root)?;\n    let source_exclude_set = build_glob_set(&config.source.exclude, project_root)?;\n    let has_source_includes = !config.source.include.is_empty();\n\n    let docs_active = config.is_docs_section_active();\n    let docs_include_set = if docs_active { build_glob_set(&config.docs.include, project_root)? } else { GlobSetBuilder::new().build().map_err(|e| AppError::Glob(e.to_string()))? };\n    let docs_exclude_set = if docs_active { build_glob_set(&config.docs.exclude, project_root)? } else { GlobSetBuilder::new().build().map_err(|e| AppError::Glob(e.to_string()))? };\n    let has_docs_includes = docs_active && !config.docs.include.is_empty();\n\n    let project_root_clone = project_root.to_path_buf();\n\n    builder.build_parallel().run(move || {\n        let tx_entry = tx_entry.clone();\n        Box::new(move |entry_result| {\n            let _ = tx_entry.send(entry_result);\n            WalkState::Continue\n        })\n    });\n\n    let mut tree_paths_types = Vec::<(String, bool)>::new();\n    let mut potential_source_files = Vec::<FileInfo>::new();\n    let mut docs_files = Vec::<FileInfo>::new();\n    let mut errors = Vec::<AppError>::new();\n    let mut docs_file_paths = HashSet::<PathBuf>::new();\n\n    for entry_result in rx_entry {\n        match entry_result {\n            Ok(entry) => {\n                let path = entry.path();\n                if entry.depth() == 0 { continue; }\n\n                // Explicitly check against cache dir relative to project root\n                // Need to import DEFAULT_CACHE_DIR from config module\n                if path.starts_with(&project_root_clone.join(crate::config::DEFAULT_CACHE_DIR)) {\n                     continue;\n                }\n\n                let absolute_path = match path.canonicalize() { Ok(p) => p, Err(_e) => continue };\n                let is_dir = entry.file_type().map_or(false, |ft| ft.is_dir());\n                let relative_path = match pathdiff::diff_paths(path, &project_root_clone) { Some(p) => p, None => continue };\n\n                if config.tree.enabled {\n                    if passes_filters_globset( &absolute_path, &relative_path, &tree_include_set, &tree_exclude_set, has_tree_includes ) {\n                        tree_paths_types.push((relative_path.to_string_lossy().to_string(), is_dir));\n                    }\n                }\n\n                if !is_dir {\n                    let mut is_doc = false;\n                    let mut is_source = false;\n\n                    if docs_active {\n                        if passes_filters_globset( &absolute_path, &relative_path, &docs_include_set, &docs_exclude_set, has_docs_includes ) { is_doc = true; }\n                    }\n                    if !is_doc && config.source.enabled {\n                        if passes_filters_globset( &absolute_path, &relative_path, &source_include_set, &source_exclude_set, has_source_includes ) { is_source = true; }\n                    }\n\n                    if is_doc || is_source {\n                        match fs::read_to_string(path) {\n                            Ok(content) => {\n                                let size = content.len();\n                                let info = FileInfo { path: path.to_path_buf(), content, size };\n                                if is_doc {\n                                    docs_files.push(info);\n                                    docs_file_paths.insert(path.to_path_buf());\n                                } else { potential_source_files.push(info); }\n                            }\n                            Err(e) => { errors.push(AppError::FileRead { path: path.to_path_buf(), source: e }); }\n                        }\n                    }\n                }\n            }\n            Err(e) => { errors.push(AppError::WalkDir(format!(\"Error walking directory: {}\", e))); }\n        }\n    }\n\n    let final_source_files: Vec<FileInfo> = potential_source_files.into_par_iter().filter(|finfo| !docs_file_paths.contains(&finfo.path)).collect();\n    let mut sorted_source_files = final_source_files;\n    sorted_source_files.par_sort_unstable_by(|a, b| a.path.cmp(&b.path));\n    let mut sorted_docs_files = docs_files;\n    sorted_docs_files.par_sort_unstable_by(|a, b| a.path.cmp(&b.path));\n    tree_paths_types.par_sort_unstable_by(|a, b| a.0.cmp(&b.0));\n\n    if !errors.is_empty() {\n        eprintln!(\"\\n{}\", \"⚠️ Warning: Errors encountered during file gathering:\".yellow());\n        for err in errors { eprintln!(\" - {}\", err); }\n        eprintln!(\"---\");\n    }\n\n    Ok((sorted_source_files, sorted_docs_files, tree_paths_types))\n}\n\n// ... build_tree_from_paths and insert_node remain the same ...\npub fn build_tree_from_paths( relative_path_types: &[(String, bool)], ) -> Result<Vec<TreeNode>, AppError> {\n    let mut root_nodes: Vec<TreeNode> = Vec::new();\n    for (rel_path_str, is_dir) in relative_path_types {\n        let rel_path = PathBuf::from(rel_path_str);\n        let components: Vec<String> = rel_path.components().filter_map(|c| match c { Component::Normal(name) => Some(name.to_string_lossy().into_owned()), _ => None }).collect();\n        if !components.is_empty() { insert_node(&mut root_nodes, &components, *is_dir)?; }\n    }\n    root_nodes.sort_by(|a, b| a.name.cmp(&b.name));\n    Ok(root_nodes)\n}\n\nfn insert_node( current_level_nodes: &mut Vec<TreeNode>, components: &[String], is_dir: bool, ) -> Result<(), AppError> {\n    if components.is_empty() { return Ok(()); }\n    let component_name = &components[0];\n    let remaining_components = &components[1..];\n    let is_last_component = remaining_components.is_empty();\n    match current_level_nodes.binary_search_by(|node| node.name.cmp(component_name)) {\n        Ok(index) => {\n            let existing_node = &mut current_level_nodes[index];\n            if is_last_component {\n                let trying_to_insert_dir = is_dir;\n                let existing_is_dir = existing_node.node_type == \"directory\";\n                if trying_to_insert_dir != existing_is_dir {\n                    eprintln!(\"Warning: Tree conflict for component '{}' - type mismatch.\", component_name);\n                    if trying_to_insert_dir { existing_node.node_type = \"directory\".to_string(); }\n                }\n            } else {\n                if existing_node.node_type == \"directory\" {\n                    if existing_node.children.is_none() { existing_node.children = Some(Vec::new()); }\n                    insert_node( existing_node.children.as_mut().unwrap(), remaining_components, is_dir, )?;\n                    existing_node.children.as_mut().unwrap().sort_by(|a, b| a.name.cmp(&b.name));\n                } else {\n                    return Err(AppError::Config(format!(\"Tree conflict: Trying to create children within file component '{}'\", component_name)));\n                }\n            }\n        }\n        Err(insertion_point) => {\n            let node_type_str = if is_last_component { if is_dir { \"directory\" } else { \"file\" } } else { \"directory\" };\n            let mut new_node = TreeNode { name: component_name.clone(), node_type: node_type_str.to_string(), children: if node_type_str == \"directory\" { Some(Vec::new()) } else { None }, };\n            if !is_last_component {\n                if let Some(children_vec) = new_node.children.as_mut() {\n                    insert_node(children_vec, remaining_components, is_dir)?;\n                    children_vec.sort_by(|a, b| a.name.cmp(&b.name));\n                } else { return Err(AppError::Config(format!(\"Tree insertion logic error for '{}'\", component_name))); }\n            }\n            current_level_nodes.insert(insertion_point, new_node);\n        }\n    }\n    Ok(())\n}\n"}],"chunk_info":{"current_part":5,"total_parts":10}}